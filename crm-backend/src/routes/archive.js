const express = require('express');
const router = express.Router();
const { authMiddleware, requirePermission } = require('../middleware/simple-auth');
const { Sale, Project, Task, sequelize } = require('../../models');
const { Op } = require('sequelize');

// Apply authentication to all routes
router.use(authMiddleware);

// Sales Archive Routes
// @route   GET /api/archive/sales
// @desc    Get archived sales with soft delete support
// @access  Private
router.get('/sales', requirePermission('manage_archive'), async (req, res) => {
  try {
    const { page = 1, limit = 50, search = '' } = req.query;
    
    // Check if Sale model exists and has deleted_at column
    const tableExists = await Sale.sequelize.query(`
      SELECT EXISTS (
        SELECT FROM information_schema.tables 
        WHERE table_schema = 'public' 
        AND table_name = 'sales'
      );
    `);
    
    if (!tableExists[0][0].exists) {
      console.log('‚ö†Ô∏è Sales table does not exist');
      return res.json({
        success: true,
        message: 'Archived sales retrieved successfully',
        data: [],
        pagination: {
          currentPage: parseInt(page),
          totalPages: 0,
          totalItems: 0,
          itemsPerPage: parseInt(limit),
          hasNextPage: false,
          hasPrevPage: false
        }
      });
    }
    
    // Check if deleted_at column exists
    const columnExists = await Sale.sequelize.query(`
      SELECT EXISTS (
        SELECT FROM information_schema.columns 
        WHERE table_name = 'sales' 
        AND column_name = 'deleted_at'
      );
    `);
    
    if (!columnExists[0][0].exists) {
      console.log('‚ö†Ô∏è Sales table does not have deleted_at column');
      return res.json({
        success: true,
        message: 'Archived sales retrieved successfully',
        data: [],
        pagination: {
          currentPage: parseInt(page),
          totalPages: 0,
          totalItems: 0,
          itemsPerPage: parseInt(limit),
          hasNextPage: false,
          hasPrevPage: false
        }
      });
    }
    
    // Build where condition for soft deleted sales
    const whereCondition = {};
    
    // Add search functionality
    if (search) {
      whereCondition[Op.or] = [
        { clientName: { [Op.iLike]: `%${search}%` } },
        { projectName: { [Op.iLike]: `%${search}%` } },
        { unitType: { [Op.iLike]: `%${search}%` } },
        { salesPerson: { [Op.iLike]: `%${search}%` } }
      ];
    }
    
    // Add condition to get only soft deleted records
    whereCondition.deleted_at = { [Op.ne]: null };
    
    // Get archived sales from database (soft deleted)
    const { rows: archivedSales, count: totalItems } = await Sale.findAndCountAll({
      where: whereCondition,
      order: [['deleted_at', 'DESC']],
      limit: parseInt(limit),
      offset: (parseInt(page) - 1) * parseInt(limit),
      paranoid: false // Include soft deleted records
    });
    
    // All results are already deleted records
    const deletedSales = archivedSales;
    
    console.log(`üìÅ Archived sales retrieved: ${deletedSales.length} items`);
    
    res.json({
      success: true,
      message: 'Archived sales retrieved successfully',
      data: deletedSales,
      pagination: {
        currentPage: parseInt(page),
        totalPages: Math.ceil(totalItems / limit),
        totalItems: totalItems, // ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ ÿßŸÑÿπÿØÿØ ÿßŸÑÿµÿ≠Ÿäÿ≠ ŸÖŸÜ findAndCountAll
        itemsPerPage: parseInt(limit),
        hasNextPage: (parseInt(page) * parseInt(limit)) < totalItems,
        hasPrevPage: parseInt(page) > 1
      }
    });
  } catch (error) {
    console.error('Error fetching archived sales:', error.message);
    console.error('Stack:', error.stack);
    res.status(500).json({
      success: false,
      message: 'ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿ¨ŸÑÿ® ÿßŸÑŸÖÿ®Ÿäÿπÿßÿ™ ÿßŸÑŸÖÿ§ÿ±ÿ¥ŸÅÿ©',
      error: error.message
    });
  }
});

// @route   PATCH /api/archive/sales/:id/restore
// @desc    Restore archived sale with soft delete support
// @access  Private
router.patch('/sales/:id/restore', requirePermission('manage_archive'), async (req, res) => {
  try {
    const { id } = req.params;
    
    // Find the soft deleted sale
    const sale = await Sale.findByPk(id, { paranoid: false });
    
    if (!sale) {
      return res.status(404).json({
        success: false,
        message: 'ÿßŸÑŸÖÿ®Ÿäÿπÿ© ÿ∫Ÿäÿ± ŸÖŸàÿ¨ŸàÿØÿ©'
      });
    }
    
    if (sale.deleted_at === null) {
      return res.status(400).json({
        success: false,
        message: 'ÿßŸÑŸÖÿ®Ÿäÿπÿ© ÿ∫Ÿäÿ± ŸÖÿ§ÿ±ÿ¥ŸÅÿ©'
      });
    }
    
    // Restore the sale
    await sale.restore();
    
    console.log(`‚ôªÔ∏è Sale restored: ${sale.id} - ${sale.clientName}`);
    
    res.json({
      success: true,
      message: 'ÿ™ŸÖ ÿßÿ≥ÿ™ÿπÿßÿØÿ© ÿßŸÑŸÖÿ®Ÿäÿπÿ© ÿ®ŸÜÿ¨ÿßÿ≠',
      data: sale
    });
  } catch (error) {
    console.error('Error restoring sale:', error);
    res.status(500).json({
      success: false,
      message: 'ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿßÿ≥ÿ™ÿπÿßÿØÿ© ÿßŸÑŸÖÿ®Ÿäÿπÿ©'
    });
  }
});

// @route   DELETE /api/archive/sales/:id/permanent
// @desc    Permanently delete sale with soft delete support
// @access  Private
router.delete('/sales/:id/permanent', requirePermission('manage_archive'), async (req, res) => {
  try {
    const { id } = req.params;
    
    // Find the soft deleted sale
    const sale = await Sale.findByPk(id, { paranoid: false });
    
    if (!sale) {
      return res.status(404).json({
        success: false,
        message: 'ÿßŸÑŸÖÿ®Ÿäÿπÿ© ÿ∫Ÿäÿ± ŸÖŸàÿ¨ŸàÿØÿ©'
      });
    }
    
    if (sale.deleted_at === null) {
      return res.status(400).json({
        success: false,
        message: 'ÿßŸÑŸÖÿ®Ÿäÿπÿ© ÿ∫Ÿäÿ± ŸÖÿ§ÿ±ÿ¥ŸÅÿ© - ŸÑÿß ŸäŸÖŸÉŸÜ ÿ≠ÿ∞ŸÅŸáÿß ŸÜŸáÿßÿ¶ŸäÿßŸã'
      });
    }
    
    // Permanently delete the sale
    await sale.destroy({ force: true });
    
    console.log(`üóëÔ∏è Sale permanently deleted: ${sale.id} - ${sale.clientName}`);
    
    res.json({
      success: true,
      message: 'ÿ™ŸÖ ÿ≠ÿ∞ŸÅ ÿßŸÑŸÖÿ®Ÿäÿπÿ© ŸÜŸáÿßÿ¶ŸäÿßŸã'
    });
  } catch (error) {
    console.error('Error permanently deleting sale:', error);
    res.status(500).json({
      success: false,
      message: 'ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿ≠ÿ∞ŸÅ ÿßŸÑŸÖÿ®Ÿäÿπÿ© ŸÜŸáÿßÿ¶ŸäÿßŸã'
    });
  }
});

// Projects Archive Routes
// @route   GET /api/archive/projects
// @desc    Get archived projects with soft delete support
// @access  Private
router.get('/projects', requirePermission('manage_archive'), async (req, res) => {
  try {
    const { page = 1, limit = 50, search = '' } = req.query;
    
    // Check if Project table exists
    const tableExists = await Project.sequelize.query(`
      SELECT EXISTS (
        SELECT FROM information_schema.tables 
        WHERE table_schema = 'public' 
        AND table_name = 'projects'
      );
    `);
    
    if (!tableExists[0][0].exists) {
      console.log('‚ö†Ô∏è Projects table does not exist');
      return res.json({
        success: true,
        message: 'Archived projects retrieved successfully',
        data: [],
        pagination: {
          currentPage: parseInt(page),
          totalPages: 0,
          totalItems: 0,
          itemsPerPage: parseInt(limit),
          hasNextPage: false,
          hasPrevPage: false
        }
      });
    }
    
    // Check if deleted_at column exists
    const columnExists = await Project.sequelize.query(`
      SELECT EXISTS (
        SELECT FROM information_schema.columns 
        WHERE table_name = 'projects' 
        AND column_name = 'deleted_at'
      );
    `);
    
    if (!columnExists[0][0].exists) {
      console.log('‚ö†Ô∏è Projects table does not have deleted_at column');
      return res.json({
        success: true,
        message: 'Archived projects retrieved successfully',
        data: [],
        pagination: {
          currentPage: parseInt(page),
          totalPages: 0,
          totalItems: 0,
          itemsPerPage: parseInt(limit),
          hasNextPage: false,
          hasPrevPage: false
        }
      });
    }
    
    // Build where condition for soft deleted projects
    const whereCondition = {};
    
    // Add search functionality
    if (search) {
      whereCondition[Op.or] = [
        { name: { [Op.iLike]: `%${search}%` } },
        { location: { [Op.iLike]: `%${search}%` } },
        { developer: { [Op.iLike]: `%${search}%` } }
      ];
    }
    
    // Add condition to get only soft deleted records
    whereCondition.deleted_at = { [Op.ne]: null };
    
    // Get archived projects from database (soft deleted)
    const { rows: archivedProjects, count: totalItems } = await Project.findAndCountAll({
      where: whereCondition,
      order: [['deleted_at', 'DESC']],
      limit: parseInt(limit),
      offset: (parseInt(page) - 1) * parseInt(limit),
      paranoid: false // Include soft deleted records
    });
    
    // All results are already deleted records
    const deletedProjects = archivedProjects;
    
    console.log(`üìÅ Archived projects retrieved: ${deletedProjects.length} items`);
    
    res.json({
      success: true,
      message: 'Archived projects retrieved successfully',
      data: deletedProjects,
      pagination: {
        currentPage: parseInt(page),
        totalPages: Math.ceil(totalItems / limit),
        totalItems: totalItems, // ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ ÿßŸÑÿπÿØÿØ ÿßŸÑÿµÿ≠Ÿäÿ≠ ŸÖŸÜ findAndCountAll
        itemsPerPage: parseInt(limit),
        hasNextPage: (parseInt(page) * parseInt(limit)) < totalItems,
        hasPrevPage: parseInt(page) > 1
      }
    });
  } catch (error) {
    console.error('Error fetching archived projects:', error.message);
    console.error('Stack:', error.stack);
    res.status(500).json({
      success: false,
      message: 'ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿ¨ŸÑÿ® ÿßŸÑŸÖÿ¥ÿßÿ±Ÿäÿπ ÿßŸÑŸÖÿ§ÿ±ÿ¥ŸÅÿ©',
      error: error.message
    });
  }
});

// @route   PATCH /api/archive/projects/:id/restore
// @desc    Restore archived project (not implemented - soft delete not supported)
// @access  Private
router.patch('/projects/:id/restore', requirePermission('manage_archive'), async (req, res) => {
  try {
    res.status(501).json({
      success: false,
      message: 'ÿßÿ≥ÿ™ÿπÿßÿØÿ© ÿßŸÑŸÖÿ¥ÿßÿ±Ÿäÿπ ÿ∫Ÿäÿ± ŸÖÿØÿπŸàŸÖÿ© ÿ≠ÿßŸÑŸäÿßŸã - Ÿäÿ¨ÿ® ÿ™ŸÅÿπŸäŸÑ soft delete ÿ£ŸàŸÑÿßŸã'
    });
  } catch (error) {
    console.error('Error restoring project:', error);
    res.status(500).json({
      success: false,
      message: 'ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿßÿ≥ÿ™ÿπÿßÿØÿ© ÿßŸÑŸÖÿ¥ÿ±Ÿàÿπ'
    });
  }
});

// @route   DELETE /api/archive/projects/:id/permanent
// @desc    Permanently delete project (not implemented - soft delete not supported)
// @access  Private
router.delete('/projects/:id/permanent', requirePermission('manage_archive'), async (req, res) => {
  try {
    res.status(501).json({
      success: false,
      message: 'ÿ≠ÿ∞ŸÅ ÿßŸÑŸÖÿ¥ÿßÿ±Ÿäÿπ ŸÜŸáÿßÿ¶ŸäÿßŸã ÿ∫Ÿäÿ± ŸÖÿØÿπŸàŸÖ ÿ≠ÿßŸÑŸäÿßŸã - Ÿäÿ¨ÿ® ÿ™ŸÅÿπŸäŸÑ soft delete ÿ£ŸàŸÑÿßŸã'
    });
  } catch (error) {
    console.error('Error permanently deleting project:', error);
    res.status(500).json({
      success: false,
      message: 'ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿ≠ÿ∞ŸÅ ÿßŸÑŸÖÿ¥ÿ±Ÿàÿπ ŸÜŸáÿßÿ¶ŸäÿßŸã'
    });
  }
});

// Tasks Archive Routes
// @route   GET /api/archive/tasks
// @desc    Get archived tasks with soft delete support
// @access  Private
router.get('/tasks', requirePermission('manage_archive'), async (req, res) => {
  try {
    const { page = 1, limit = 50, search = '' } = req.query;
    
    // Build where condition for soft deleted tasks
    const whereCondition = {};
    
    // Add search functionality
    if (search) {
      whereCondition[Op.or] = [
        { title: { [Op.iLike]: `%${search}%` } },
        { description: { [Op.iLike]: `%${search}%` } },
        { assignedTo: { [Op.iLike]: `%${search}%` } }
      ];
    }
    
    // Add condition to get only soft deleted records
    whereCondition.deleted_at = { [Op.ne]: null };
    
    // Get archived tasks from database (soft deleted)
    const { rows: archivedTasks, count: totalItems } = await Task.findAndCountAll({
      where: whereCondition,
      order: [['deleted_at', 'DESC']],
      limit: parseInt(limit),
      offset: (parseInt(page) - 1) * parseInt(limit),
      paranoid: false // Include soft deleted records
    });
    
    // All results are already deleted records
    const deletedTasks = archivedTasks;
    
    console.log(`üìÅ Archived tasks retrieved: ${deletedTasks.length} items`);
    
    res.json({
      success: true,
      message: 'Archived tasks retrieved successfully',
      data: deletedTasks,
      pagination: {
        currentPage: parseInt(page),
        totalPages: Math.ceil(totalItems / limit),
        totalItems: deletedTasks.length,
        itemsPerPage: parseInt(limit),
        hasNextPage: (parseInt(page) * parseInt(limit)) < deletedTasks.length,
        hasPrevPage: parseInt(page) > 1
      }
    });
  } catch (error) {
    console.error('Error fetching archived tasks:', error);
    res.status(500).json({
      success: false,
      message: 'ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿ¨ŸÑÿ® ÿßŸÑŸÖŸáÿßŸÖ ÿßŸÑŸÖÿ§ÿ±ÿ¥ŸÅÿ©'
    });
  }
});

// @route   PATCH /api/archive/tasks/:id/restore
// @desc    Restore archived task with soft delete support
// @access  Private
router.patch('/tasks/:id/restore', requirePermission('manage_archive'), async (req, res) => {
  try {
    const { id } = req.params;
    
    // Find the soft deleted task
    const task = await Task.findByPk(id, { paranoid: false });
    
    if (!task) {
      return res.status(404).json({
        success: false,
        message: 'ÿßŸÑŸÖŸáŸÖÿ© ÿ∫Ÿäÿ± ŸÖŸàÿ¨ŸàÿØÿ©'
      });
    }
    
    if (task.deleted_at === null) {
      return res.status(400).json({
        success: false,
        message: 'ÿßŸÑŸÖŸáŸÖÿ© ÿ∫Ÿäÿ± ŸÖÿ§ÿ±ÿ¥ŸÅÿ©'
      });
    }
    
    // Restore the task
    await task.restore();
    
    console.log(`‚ôªÔ∏è Task restored: ${task.id} - ${task.title}`);
    
    res.json({
      success: true,
      message: 'ÿ™ŸÖ ÿßÿ≥ÿ™ÿπÿßÿØÿ© ÿßŸÑŸÖŸáŸÖÿ© ÿ®ŸÜÿ¨ÿßÿ≠',
      data: task
    });
  } catch (error) {
    console.error('Error restoring task:', error);
    res.status(500).json({
      success: false,
      message: 'ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿßÿ≥ÿ™ÿπÿßÿØÿ© ÿßŸÑŸÖŸáŸÖÿ©'
    });
  }
});

// @route   DELETE /api/archive/tasks/:id/permanent
// @desc    Permanently delete task with soft delete support
// @access  Private
router.delete('/tasks/:id/permanent', requirePermission('manage_archive'), async (req, res) => {
  try {
    const { id } = req.params;
    
    // Find the soft deleted task
    const task = await Task.findByPk(id, { paranoid: false });
    
    if (!task) {
      return res.status(404).json({
        success: false,
        message: 'ÿßŸÑŸÖŸáŸÖÿ© ÿ∫Ÿäÿ± ŸÖŸàÿ¨ŸàÿØÿ©'
      });
    }
    
    if (task.deleted_at === null) {
      return res.status(400).json({
        success: false,
        message: 'ÿßŸÑŸÖŸáŸÖÿ© ÿ∫Ÿäÿ± ŸÖÿ§ÿ±ÿ¥ŸÅÿ© - ŸÑÿß ŸäŸÖŸÉŸÜ ÿ≠ÿ∞ŸÅŸáÿß ŸÜŸáÿßÿ¶ŸäÿßŸã'
      });
    }
    
    // Permanently delete the task
    await task.destroy({ force: true });
    
    console.log(`üóëÔ∏è Task permanently deleted: ${task.id} - ${task.title}`);
    
    res.json({
      success: true,
      message: 'ÿ™ŸÖ ÿ≠ÿ∞ŸÅ ÿßŸÑŸÖŸáŸÖÿ© ŸÜŸáÿßÿ¶ŸäÿßŸã'
    });
  } catch (error) {
    console.error('Error permanently deleting task:', error);
    res.status(500).json({
      success: false,
      message: 'ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿ≠ÿ∞ŸÅ ÿßŸÑŸÖŸáŸÖÿ© ŸÜŸáÿßÿ¶ŸäÿßŸã'
    });
  }
});

module.exports = router;
