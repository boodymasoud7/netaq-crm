const { FollowUp, Lead, Client, Sale, User } = require('../../models');
const { Op } = require('sequelize');
const FollowUpIntegrationService = require('./followUpIntegrationService');

class AutoFollowUpService {
  
  /**
   * حساب التاريخ والوقت المناسب للمتابعة في أوقات العمل
   * @param {number} daysToAdd - عدد الأيام للإضافة
   * @param {string} preferredTime - الوقت المفضل ('morning'|'afternoon'|'random')
   * @returns {Date} التاريخ والوقت المضبوط
   */
  static calculateWorkingDateTime(daysToAdd, preferredTime = 'morning') {
    console.log(`🕐 calculateWorkingDateTime called: daysToAdd=${daysToAdd}, preferredTime=${preferredTime}`);
    
    // تحديد الساعة والدقيقة في أوقات العمل (11 ص - 7 مساءً)
    let workingHour;
    let workingMinute = Math.floor(Math.random() * 60); // دقيقة عشوائية
    
    switch (preferredTime) {
      case 'morning':
        workingHour = 11 + Math.floor(Math.random() * 3); // 11, 12, 13
        break;
      case 'afternoon':
        workingHour = 15 + Math.floor(Math.random() * 3); // 15, 16, 17
        break;
      case 'random':
      default:
        workingHour = 11 + Math.floor(Math.random() * 8); // 11-18
        break;
    }
    
    console.log(`⏰ Selected working time: ${workingHour}:${workingMinute.toString().padStart(2, '0')}`);
    
    // إنشاء التاريخ بطريقة مباشرة وواضحة
    const targetDate = new Date();
    const currentYear = targetDate.getFullYear();
    const currentMonth = targetDate.getMonth();
    const currentDay = targetDate.getDate();
    
    // إنشاء تاريخ جديد بالساعة المحددة
    const newDate = new Date(currentYear, currentMonth, currentDay + daysToAdd, workingHour, workingMinute, 0, 0);
    
    console.log(`📅 Before weekend check: ${newDate.toISOString()}`);
    
    // تجنب نهاية الأسبوع (الجمعة = 5، السبت = 6)
    while (newDate.getDay() === 5 || newDate.getDay() === 6) {
      newDate.setDate(newDate.getDate() + 1);
      console.log(`⏭️ Skipping weekend, moved to: ${newDate.toISOString()}`);
    }
    
    // إذا كان الوقت في الماضي، انتقل لليوم التالي
    const now = new Date();
    if (newDate <= now) {
      newDate.setDate(newDate.getDate() + 1);
      // تجنب نهاية الأسبوع مرة أخرى
      while (newDate.getDay() === 5 || newDate.getDay() === 6) {
        newDate.setDate(newDate.getDate() + 1);
      }
      console.log(`⏭️ Time was in past, moved to: ${newDate.toISOString()}`);
    }
    
    const dayNames = ['الأحد','الاثنين','الثلاثاء','الأربعاء','الخميس','الجمعة','السبت'];
    console.log(`✅ Final scheduled time: ${newDate.toISOString()} (${dayNames[newDate.getDay()]}) - Local: ${workingHour}:${workingMinute.toString().padStart(2, '0')}`);
    
    return newDate;
  }
  
  // إنشاء متابعة أولى فقط لعميل محتمل جديد
  static async createLeadFollowUps(leadId, assignedToUserId, createdByUserId = null) {
    try {
      const lead = await Lead.findByPk(leadId);
      if (!lead) {
        throw new Error(`Lead not found: ${leadId}`);
      }

      // لا نحتاج للتحقق من المتابعات الموجودة لأن هذه الدالة تُستدعى فقط عند التوزيع الأول

      const followUps = [];
      
      // متابعة مؤجلة - اتصال ترحيبي
      const firstFollowUp = await FollowUp.create({
        leadId: leadId,
        type: 'call',
        title: `اتصال ترحيبي - ${lead.name}`,
        description: `اتصال ترحيبي للعميل المحتمل الجديد للتعرف على احتياجاته وتقديم الخدمات المناسبة. مجدولة في وقت العمل.`,
        scheduledDate: this.calculateWorkingDateTime(1, 'morning'), // غداً صباحاً
        priority: 'high',
        assignedTo: assignedToUserId, // الموظف المخصص له العميل
        createdBy: createdByUserId || assignedToUserId, // المدير الذي قام بالتوزيع
        contactMethod: 'phone',
        expectedOutcome: 'فهم احتياجات العميل وتحديد مستوى اهتمامه',
        notes: 'متابعة أولى تلقائية - المتابعة التالية ستتم حسب النتيجة',
        isAutoGenerated: true
      });
      followUps.push(firstFollowUp);
      
      // لا ننشئ متابعات إضافية - ستتم حسب نتيجة المتابعة الأولى
      
      console.log(`✅ Created 1 initial follow-up for lead ${leadId}`);
      
      // إنشاء تذكير وإشعار للمتابعة الأولى
      await FollowUpIntegrationService.createReminderForFollowUp(firstFollowUp);
      
      return followUps;
      
    } catch (error) {
      console.error(`❌ Error creating auto follow-ups for lead ${leadId}:`, error);
      throw error;
    }
  }
  
  // إنشاء متابعات تلقائية لعميل فعلي جديد
  static async createClientFollowUps(clientId, assignedToUserId, createdByUserId = null) {
    try {
      const client = await Client.findByPk(clientId);
      if (!client) {
        throw new Error(`Client not found: ${clientId}`);
      }

      // لا نحتاج للتحقق من المتابعات الموجودة لأن هذه الدالة تُستدعى فقط عند التوزيع الأول

      const followUps = [];
      
      // متابعة ترحيبية
      // تحديد وقت الاتصال حسب أوقات العمل
      
      const welcomeFollowUp = await FollowUp.create({
        clientId: clientId,
        type: 'call',
        title: `اتصال ترحيبي - ${client.name}`,
        description: `اتصال ترحيبي للعميل الجديد للتأكد من رضاه وتقديم الدعم اللازم.`,
        scheduledDate: this.calculateWorkingDateTime(0, 'afternoon'), // اليوم بعد الظهر أو غداً
        priority: 'high',
        assignedTo: assignedToUserId, // الموظف المخصص له العميل
        createdBy: createdByUserId || assignedToUserId, // المدير الذي قام بالتوزيع
        contactMethod: 'phone',
        expectedOutcome: 'تأكيد رضا العميل وفهم متطلباته',
        isAutoGenerated: true
      });
      followUps.push(welcomeFollowUp);
      
      // متابعة دورية بعد أسبوع
      const weeklyFollowUpDate = new Date();
      weeklyFollowUpDate.setDate(weeklyFollowUpDate.getDate() + 7);
      
      const weeklyFollowUp = await FollowUp.create({
        clientId: clientId,
        type: 'call',
        title: `متابعة دورية - ${client.name}`,
        description: `متابعة دورية للتأكد من سير الخدمة بشكل مثالي.`,
        scheduledDate: weeklyFollowUpDate,
        priority: 'medium',
        assignedTo: assignedToUserId,
        createdBy: assignedToUserId,
        contactMethod: 'phone',
        expectedOutcome: 'تأكيد استمرار الرضا وتحديد فرص جديدة',
        isAutoGenerated: true
      });
      followUps.push(weeklyFollowUp);
      
      console.log(`✅ Created ${followUps.length} auto follow-ups for client ${clientId}`);
      
      // إنشاء تذكيرات وإشعارات لكل متابعة
      for (const followUp of followUps) {
        await FollowUpIntegrationService.createReminderForFollowUp(followUp);
      }
      
      return followUps;
      
    } catch (error) {
      console.error(`❌ Error creating auto follow-ups for client ${clientId}:`, error);
      throw error;
    }
  }
  
  // إنشاء متابعة تالية بناءً على نتيجة المتابعة المكتملة
  static async createNextFollowUp(completedFollowUp, outcome, nextAction, assignedToUserId, createdByUserId = null) {
    try {
      console.log(`🔄 Creating next follow-up based on outcome: ${outcome}`);
      
      let followUpData = {};
      const baseDate = new Date();
      
      switch (outcome) {
        case 'interested':
          followUpData = {
            type: 'call',
            title: `متابعة اهتمام - ${completedFollowUp.lead?.name || completedFollowUp.client?.name || 'عميل'}`,
            description: `العميل أبدى اهتماماً، متابعة لتحديد الخطوات التالية والمتطلبات.`,
            scheduledDate: this.calculateWorkingDateTime(2, 'morning'), // بعد يومين صباحاً
            priority: 'high',
            expectedOutcome: 'جدولة عرض تقديمي أو إرسال معلومات إضافية'
          };
          break;
          
        case 'needs_info':
          followUpData = {
            type: 'email',
            title: `إرسال معلومات - ${completedFollowUp.lead?.name || completedFollowUp.client?.name || 'عميل'}`,
            description: `العميل يحتاج معلومات إضافية، إرسال المواد المطلوبة ومتابعة.`,
            scheduledDate: this.calculateWorkingDateTime(1, 'morning'), // غداً صباحاً
            priority: 'high',
            expectedOutcome: 'مراجعة العميل للمعلومات واتخاذ قرار'
          };
          break;
          
        case 'call_later':
          followUpData = {
            type: 'call',
            title: `إعادة اتصال - ${completedFollowUp.lead?.name || completedFollowUp.client?.name || 'عميل'}`,
            description: `العميل طلب إعادة الاتصال في وقت لاحق.`,
            scheduledDate: this.calculateWorkingDateTime(3, 'afternoon'), // بعد 3 أيام بعد الظهر
            priority: 'medium',
            expectedOutcome: 'تواصل ناجح وتحديد الخطوات التالية'
          };
          break;
          
        case 'meeting_scheduled':
          followUpData = {
            type: 'meeting',
            title: `متابعة بعد الاجتماع - ${completedFollowUp.lead?.name || completedFollowUp.client?.name || 'عميل'}`,
            description: `متابعة ما بعد الاجتماع المجدول لمعرفة القرار النهائي.`,
            scheduledDate: this.calculateWorkingDateTime(7, 'morning'), // بعد أسبوع صباحاً
            priority: 'high',
            expectedOutcome: 'الحصول على قرار نهائي من العميل'
          };
          break;
          
        case 'quotation_sent':
          followUpData = {
            type: 'call',
            title: `متابعة عرض السعر - ${completedFollowUp.lead?.name || completedFollowUp.client?.name || 'عميل'}`,
            description: `متابعة عرض السعر المرسل للعميل ومعرفة رأيه.`,
            scheduledDate: this.calculateWorkingDateTime(2, 'afternoon'), // بعد يومين بعد الظهر
            priority: 'high',
            expectedOutcome: 'موافقة العميل على العرض أو تعديل المطلوب'
          };
          break;
          
        case 'no_answer':
          followUpData = {
            type: 'call',
            title: `إعادة المحاولة - ${completedFollowUp.lead?.name || completedFollowUp.client?.name || 'عميل'}`,
            description: `لم يتم الرد على الاتصال، إعادة المحاولة.`,
            scheduledDate: this.calculateWorkingDateTime(1, 'random'), // غداً في وقت عشوائي
            priority: 'medium',
            expectedOutcome: 'الوصول للعميل والتحدث معه'
          };
          break;
          
        case 'not_interested':
          // لا ننشئ متابعة إضافية للعملاء غير المهتمين
          console.log(`⏸️ No next follow-up needed for "not_interested" outcome`);
          return null;
          
        default:
          // متابعة عامة للنتائج الأخرى
          followUpData = {
            type: 'call',
            title: `متابعة عامة - ${completedFollowUp.lead?.name || completedFollowUp.client?.name || 'عميل'}`,
            description: nextAction || `متابعة عامة بناءً على النتيجة: ${outcome}`,
            scheduledDate: this.calculateWorkingDateTime(3, 'random'), // بعد 3 أيام في وقت عشوائي
            priority: 'medium',
            expectedOutcome: 'تحديد الخطوات التالية مع العميل'
          };
      }
      
      // إضافة البيانات المشتركة
      const nextFollowUp = await FollowUp.create({
        ...followUpData,
        leadId: completedFollowUp.leadId,
        clientId: completedFollowUp.clientId,
        saleId: completedFollowUp.saleId,
        assignedTo: assignedToUserId,
        createdBy: createdByUserId || assignedToUserId,
        contactMethod: followUpData.type === 'email' ? 'email' : 'phone',
        notes: `متابعة تلقائية بناءً على النتيجة: ${outcome}`,
        isAutoGenerated: true
      });
      
      console.log(`✅ Created next follow-up: ${nextFollowUp.title}`);
      
      // إنشاء تذكير للمتابعة الجديدة
      await FollowUpIntegrationService.createReminderForFollowUp(nextFollowUp);
      
      return nextFollowUp;
      
    } catch (error) {
      console.error(`❌ Error creating next follow-up:`, error);
      throw error;
    }
  }
  
  // إنشاء متابعة بناءً على تغيير حالة العميل المحتمل
  static async createFollowUpBasedOnStatus(leadId, newStatus, assignedToUserId) {
    try {
      console.log(`🔄 Creating status-based follow-up for Lead ${leadId}: ${newStatus}`);
      
      const lead = await Lead.findByPk(leadId);
      if (!lead) {
        throw new Error(`Lead not found: ${leadId}`);
      }

      let followUpData = {};
      const baseDate = new Date();
      
      switch (newStatus) {
        case 'interested':
          followUpData = {
            type: 'call',
            title: `متابعة اهتمام - ${lead.name}`,
            description: `العميل أبدى اهتماماً، متابعة لتحديد الخطوات التالية.`,
            scheduledDate: new Date(baseDate.getTime() + 24 * 60 * 60 * 1000), // غداً
            priority: 'high',
            expectedOutcome: 'جدولة عرض تقديمي أو إرسال معلومات إضافية'
          };
          break;
          
        case 'contacted':
          followUpData = {
            type: 'call',
            title: `متابعة بعد التواصل - ${lead.name}`,
            description: `متابعة بعد التواصل الأولي لمعرفة الرأي والخطوات التالية.`,
            scheduledDate: new Date(baseDate.getTime() + 2 * 24 * 60 * 60 * 1000), // بعد يومين
            priority: 'medium',
            expectedOutcome: 'تأكيد الاهتمام وتحديد موعد للقاء'
          };
          break;
          
        case 'qualified':
          followUpData = {
            type: 'demo',
            title: `عرض تقديمي - ${lead.name}`,
            description: `عميل مؤهل، جدولة عرض تقديمي تفصيلي.`,
            scheduledDate: new Date(baseDate.getTime() + 3 * 24 * 60 * 60 * 1000), // بعد 3 أيام
            priority: 'high',
            expectedOutcome: 'إقناع العميل وإرسال عرض سعر'
          };
          break;
          
        case 'proposal_sent':
          followUpData = {
            type: 'call',
            title: `متابعة عرض السعر - ${lead.name}`,
            description: `متابعة بعد إرسال عرض السعر لمعرفة الرد.`,
            scheduledDate: new Date(baseDate.getTime() + 3 * 24 * 60 * 60 * 1000), // بعد 3 أيام
            priority: 'high',
            expectedOutcome: 'الحصول على رد وإتمام الصفقة'
          };
          break;
          
        case 'negotiation':
          followUpData = {
            type: 'meeting',
            title: `اجتماع تفاوض - ${lead.name}`,
            description: `اجتماع لمناقشة التفاصيل والوصول لاتفاق نهائي.`,
            scheduledDate: new Date(baseDate.getTime() + 24 * 60 * 60 * 1000), // غداً
            priority: 'urgent',
            expectedOutcome: 'الوصول لاتفاق نهائي وإتمام الصفقة'
          };
          break;
          
        case 'not_interested':
          followUpData = {
            type: 'email',
            title: `متابعة مستقبلية - ${lead.name}`,
            description: `متابعة مستقبلية للعميل غير المهتم حالياً.`,
            scheduledDate: new Date(baseDate.getTime() + 30 * 24 * 60 * 60 * 1000), // بعد شهر
            priority: 'low',
            expectedOutcome: 'التحقق من تغيير الظروف والاهتمام المستقبلي'
          };
          break;
          
        default:
          console.log(`No auto follow-up rule for status: ${newStatus}`);
          return null;
      }
      
      const followUp = await FollowUp.create({
        leadId: leadId,
        ...followUpData,
        assignedTo: assignedToUserId,
        createdBy: assignedToUserId,
        contactMethod: followUpData.type === 'call' ? 'phone' : 'email',
        isAutoGenerated: true
      });
      
      console.log(`✅ Created status-based follow-up for lead ${leadId}: ${followUp.id}`);
      return followUp;
      
    } catch (error) {
      console.error(`❌ Error creating status-based follow-up for lead ${leadId}:`, error);
      throw error;
    }
  }
  
  // جدولة متابعات تلقائية دورية (يتم تشغيلها من cron job)
  static async scheduleAutomaticFollowUps() {
    try {
      console.log('🤖 Running automatic follow-up scheduling...');
      
      const today = new Date();
      today.setHours(0, 0, 0, 0);
      
      // البحث عن العملاء المحتملين الذين لم تتم متابعتهم منذ أكثر من 7 أيام
      const staleLeads = await Lead.findAll({
        where: {
          status: {
            [Op.notIn]: ['converted', 'lost', 'not_interested']
          },
          assignedTo: {
            [Op.ne]: null
          },
          updatedAt: {
            [Op.lt]: new Date(today.getTime() - 7 * 24 * 60 * 60 * 1000)
          }
        }
      });
      
      let createdFollowUps = 0;
      
      for (const lead of staleLeads) {
        // تحقق من عدم وجود متابعات مجدولة لهذا العميل
        const existingFollowUp = await FollowUp.findOne({
          where: {
            leadId: lead.id,
            status: 'scheduled',
            scheduledDate: {
              [Op.gte]: today
            }
          }
        });
        
        if (!existingFollowUp) {
          await this.createFollowUpBasedOnStatus(lead.id, lead.status, lead.assignedTo);
          createdFollowUps++;
        }
      }
      
      console.log(`✅ Automatic follow-up scheduling completed: ${createdFollowUps} follow-ups created`);
      return { success: true, created: createdFollowUps };
      
    } catch (error) {
      console.error('❌ Error in automatic follow-up scheduling:', error);
      throw error;
    }
  }
  
  // توزيع متابعات للعملاء المحتملين الموزعين (للاستخدام من الفرونت إند)
  static async distributeFollowUpsWithLeads(followUpAssignments, createdBy) {
    try {
      console.log(`🎯 Distributing follow-ups for ${followUpAssignments.length} leads`);
      
      const results = [];
      
      for (const assignment of followUpAssignments) {
        try {
          console.log(`🎯 Creating follow-ups for Lead ${assignment.leadId} → User ${assignment.assignedTo}`);
          const followUps = await this.createLeadFollowUps(
            assignment.leadId, 
            assignment.assignedTo,
            createdBy
          );
          
          results.push({
            leadId: assignment.leadId,
            leadName: assignment.leadName,
            assignedTo: assignment.assignedTo,
            followUpsCreated: followUps.length,
            success: true
          });
          
        } catch (error) {
          console.error(`❌ Failed to create follow-ups for lead ${assignment.leadId}:`, error);
          results.push({
            leadId: assignment.leadId,
            leadName: assignment.leadName,
            assignedTo: assignment.assignedTo,
            followUpsCreated: 0,
            success: false,
            error: error.message
          });
        }
      }
      
      const successful = results.filter(r => r.success).length;
      console.log(`✅ Follow-up distribution completed: ${successful}/${results.length} successful`);
      
      return results;
      
    } catch (error) {
      console.error('❌ Error in follow-up distribution:', error);
      throw error;
    }
  }
}

module.exports = AutoFollowUpService;
