const { FollowUp, Lead, Client, User, sequelize } = require('../../models');
const { body, validationResult, query } = require('express-validator');
const { Op } = require('sequelize');
const AutoFollowUpService = require('../services/autoFollowUpService');
const FollowUpIntegrationService = require('../services/followUpIntegrationService');

// Ø¥Ù†Ø´Ø§Ø¡ Ù…ØªØ§Ø¨Ø¹Ø© Ø¬Ø¯ÙŠØ¯Ø©
exports.createFollowUp = async (req, res) => {
  try {
    console.log('ğŸ“ Creating new follow-up:', req.body);

    const {
      title,
      description,
      scheduledDate,
      status = 'pending',
      priority = 'medium',
      type = 'call',
      leadId,
      clientId,
      assignedTo,
      notes,
      reminderBefore
    } = req.body;

    // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ÙˆØ¬ÙˆØ¯ Ø§Ù„Ø­Ù‚ÙˆÙ„ Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø©
    if (!title || !scheduledDate) {
      return res.status(400).json({
        success: false,
        message: 'Ø§Ù„Ø¹Ù†ÙˆØ§Ù† ÙˆØªØ§Ø±ÙŠØ® Ø§Ù„Ø¬Ø¯ÙˆÙ„Ø© Ù…Ø·Ù„ÙˆØ¨Ø§Ù†'
      });
    }

    // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ÙˆØ¬ÙˆØ¯ leadId Ø£Ùˆ clientId
    if (!leadId && !clientId) {
      return res.status(400).json({
        success: false,
        message: 'ÙŠØ¬Ø¨ ØªØ­Ø¯ÙŠØ¯ Ø¹Ù…ÙŠÙ„ Ù…Ø­ØªÙ…Ù„ Ø£Ùˆ Ø¹Ù…ÙŠÙ„'
      });
    }

    // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØµØ­Ø© assignedTo
    if (assignedTo) {
      const assignedUser = await User.findByPk(assignedTo);
      if (!assignedUser) {
        return res.status(400).json({
          success: false,
          message: 'Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø§Ù„Ù…Ø®ØµØµ ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯'
        });
      }
    }

    // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØµØ­Ø© leadId Ø¥Ø°Ø§ ØªÙ… ØªÙ…Ø±ÙŠØ±Ù‡
    if (leadId) {
      const lead = await Lead.findByPk(leadId);
      if (!lead) {
        return res.status(400).json({
          success: false,
          message: 'Ø§Ù„Ø¹Ù…ÙŠÙ„ Ø§Ù„Ù…Ø­ØªÙ…Ù„ ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯'
        });
      }
    }

    // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØµØ­Ø© clientId Ø¥Ø°Ø§ ØªÙ… ØªÙ…Ø±ÙŠØ±Ù‡
    if (clientId) {
      const client = await Client.findByPk(clientId);
      if (!client) {
        console.error(`âŒ Client ID ${clientId} not found in database`);
        return res.status(400).json({
          success: false,
          message: `Ø§Ù„Ø¹Ù…ÙŠÙ„ Ø±Ù‚Ù… ${clientId} ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯ ÙÙŠ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª`
        });
      }
    }

    // Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù…ØªØ§Ø¨Ø¹Ø©
    const followUp = await FollowUp.create({
      title,
      description,
      scheduledDate: new Date(scheduledDate),
      status,
      priority,
      type,
      leadId: leadId || null,
      clientId: clientId || null,
      assignedTo: assignedTo || req.user.id,
      createdBy: req.user.id,
      notes,
      reminderBefore
    });

    // Ø¥Ù†Ø´Ø§Ø¡ ØªØ°ÙƒÙŠØ± Ø¥Ø°Ø§ ØªÙ… ØªØ­Ø¯ÙŠØ¯ reminderBefore
    if (reminderBefore && reminderBefore > 0) {
      try {
        await FollowUpIntegrationService.createReminderForFollowUp(followUp);
        console.log('âœ… Reminder created for follow-up');
      } catch (reminderError) {
        console.warn('âš ï¸ Failed to create reminder:', reminderError.message);
        // Ù„Ø§ Ù†Ø±ÙŠØ¯ ÙØ´Ù„ Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù…ØªØ§Ø¨Ø¹Ø© Ø¨Ø³Ø¨Ø¨ ÙØ´Ù„ ÙÙŠ Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„ØªØ°ÙƒÙŠØ±
      }
    }

    // Ø¥Ø±Ø¬Ø§Ø¹ Ø§Ù„Ù…ØªØ§Ø¨Ø¹Ø© Ù…Ø¨Ø§Ø´Ø±Ø© Ø¨Ø¯ÙˆÙ† Ù…Ø¹Ù‚Ø¯Ø§Øª
    const fullFollowUp = followUp;

    console.log('âœ… Follow-up created successfully');
    console.log('ğŸ” Follow-up details:', {
      id: followUp.id,
      title: title,
      clientId: clientId || 'none',
      leadId: leadId || 'none',
      assignedTo: assignedTo || req.user.id,
      createdBy: req.user.id,
      isAutoGenerated: followUp.isAutoGenerated || false
    });

    res.status(201).json({
      success: true,
      message: 'ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù…ØªØ§Ø¨Ø¹Ø© Ø¨Ù†Ø¬Ø§Ø­',
      data: fullFollowUp
    });

  } catch (error) {
    console.error('âŒ Error creating follow-up:', error);
    res.status(500).json({
      success: false,
      message: 'Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù…ØªØ§Ø¨Ø¹Ø©',
      error: error.message
    });
  }
};

// Ø¬Ù„Ø¨ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù…ØªØ§Ø¨Ø¹Ø§Øª Ù…Ø¹ Ø§Ù„ØªØµÙÙŠØ© ÙˆØ§Ù„ØªØ±Ù‚ÙŠÙ…
exports.getAllFollowUps = async (req, res) => {
  try {
    const {
      page = 1,
      limit = 20,
      status,
      priority,
      type,
      assignedTo,
      userFilter,
      search,
      startDate,
      endDate,
      overdue = false
    } = req.query;

    console.log('ğŸ“‹ Fetching follow-ups with filters:', req.query);

    const offset = (page - 1) * limit;
    const where = {};
    const include = [
      {
        model: Lead,
        as: 'lead',
        attributes: ['id', 'name', 'phone', 'email'],
        paranoid: false // Include deleted leads
      },
      {
        model: Client,
        as: 'client',
        attributes: ['id', 'name', 'phone', 'email'],
        paranoid: false // Include deleted clients
      },
      {
        model: User,
        as: 'assignedUser',
        attributes: ['id', 'name', 'email']
      },
      {
        model: User,
        as: 'creator',
        attributes: ['id', 'name', 'email']
      }
    ];

    // ÙÙ„ØªØ±Ø© Ø­Ø³Ø¨ Ø§Ù„Ø­Ø§Ù„Ø©
    if (status) {
      where.status = status;
    }

    // ÙÙ„ØªØ±Ø© Ø­Ø³Ø¨ Ø§Ù„Ø£ÙˆÙ„ÙˆÙŠØ©
    if (priority) {
      where.priority = priority;
    }

    // ÙÙ„ØªØ±Ø© Ø­Ø³Ø¨ Ø§Ù„Ù†ÙˆØ¹
    if (type) {
      where.type = type;
    }

    // ÙÙ„ØªØ±Ø© Ø­Ø³Ø¨ Ø§Ù„Ù…Ø®ØµØµ Ù„Ù‡
    if (assignedTo) {
      where.assignedTo = assignedTo;
    }

    // Ø§Ù„Ø¨Ø­Ø« Ø§Ù„Ù†ØµÙŠ
    if (search) {
      where[Op.or] = [
        { title: { [Op.iLike]: `%${search}%` } },
        { description: { [Op.iLike]: `%${search}%` } },
        { notes: { [Op.iLike]: `%${search}%` } }
      ];
    }

    // ÙÙ„ØªØ±Ø© Ø´Ø§Ù…Ù„Ø© Ø¨Ù€ userFilter (Ù…Ø®ØµØµ Ù„Ù‡ Ø£Ùˆ Ø£Ù†Ø´Ø£Ù‡) - ÙÙ‚Ø· Ø¥Ø°Ø§ Ù„Ù… ÙŠÙƒÙ† Ù‡Ù†Ø§Ùƒ Ø¨Ø­Ø« Ù†ØµÙŠ
    if (userFilter && !search) {
      where[Op.or] = [
        { assignedTo: parseInt(userFilter) },
        { createdBy: parseInt(userFilter) }
      ];
    }

    // ÙÙ„ØªØ±Ø© Ø­Ø³Ø¨ Ø§Ù„ØªØ§Ø±ÙŠØ®
    if (startDate || endDate) {
      where.scheduledDate = {};
      if (startDate) {
        where.scheduledDate[Op.gte] = new Date(startDate);
      }
      if (endDate) {
        where.scheduledDate[Op.lte] = new Date(endDate);
      }
    }

    // ÙÙ„ØªØ±Ø© Ø§Ù„Ù…ØªØ£Ø®Ø±Ø©
    if (overdue === 'true') {
      where.scheduledDate = { [Op.lt]: new Date() };
      where.status = { [Op.not]: 'done' };
    }

    // Ø¥Ø¶Ø§ÙØ© ÙÙ„ØªØ±Ø© Ø¯ÙˆØ± Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
    const userRole = req.user.role;
    if (userRole === 'sales' || userRole === 'sales_agent') {
      // Ù…ÙˆØ¸ÙÙŠ Ø§Ù„Ù…Ø¨ÙŠØ¹Ø§Øª ÙŠØ±ÙˆÙ† Ø§Ù„Ù…ØªØ§Ø¨Ø¹Ø§Øª Ø§Ù„Ù…Ø®ØµØµØ© Ù„Ù‡Ù… ÙÙ‚Ø·
      // ØªØ­ÙˆÙŠÙ„ Ù„Ù€ number Ù„Ù„ØªØ£ÙƒØ¯ Ù…Ù† Ø§Ù„ØªØ·Ø§Ø¨Ù‚ Ù…Ø¹ assignedTo ÙÙŠ database
      where.assignedTo = parseInt(req.user.id);
    }
    // Ø§Ù„Ù…Ø¯ÙŠØ± ÙˆØ§Ù„Ø£Ø¯Ù…Ù† ÙŠØ±ÙˆÙ† Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù…ØªØ§Ø¨Ø¹Ø§Øª (Ù„Ø§ ÙÙ„ØªØ±Ø© Ø¥Ø¶Ø§ÙÙŠØ©)

    const followUps = await FollowUp.findAndCountAll({
      where,
      include,
      order: [['scheduledDate', 'ASC'], ['priority', 'DESC']],
      limit: parseInt(limit),
      offset: parseInt(offset),
      distinct: true, // Ù…Ù†Ø¹ Ø§Ù„ØªÙƒØ±Ø§Ø± Ø¨Ø³Ø¨Ø¨ Ø§Ù„Ù€ joins Ø§Ù„Ù…ØªØ¹Ø¯Ø¯Ø©
      subQuery: false // ØªØ­Ø³ÙŠÙ† Ø§Ù„Ø£Ø¯Ø§Ø¡ Ù…Ø¹ Ø§Ù„Ù€ includes
    });

    // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ÙˆØ¬ÙˆØ¯ ØªÙƒØ±Ø§Ø±
    const uniqueIds = [...new Set(followUps.rows.map(f => f.id))];
    if (uniqueIds.length !== followUps.rows.length) {
      console.warn(`âš ï¸ DUPLICATES DETECTED! Unique IDs: ${uniqueIds.length}, Total rows: ${followUps.rows.length}`);
    }

    res.json({
      success: true,
      data: followUps.rows,
      pagination: {
        total: followUps.count,
        page: parseInt(page),
        limit: parseInt(limit),
        totalPages: Math.ceil(followUps.count / limit)
      }
    });

  } catch (error) {
    console.error('âŒ Error fetching follow-ups:', error);
    res.status(500).json({
      success: false,
      message: 'Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø¬Ù„Ø¨ Ø§Ù„Ù…ØªØ§Ø¨Ø¹Ø§Øª',
      error: error.message
    });
  }
};

// Ø¬Ù„Ø¨ Ù…ØªØ§Ø¨Ø¹Ø© ÙˆØ§Ø­Ø¯Ø©
exports.getFollowUpById = async (req, res) => {
  try {
    const { id } = req.params;
    console.log('ğŸ” Fetching follow-up:', id);

    const followUp = await FollowUp.findByPk(id, {
      include: [
        {
          model: Lead,
          as: 'lead',
          attributes: ['id', 'name', 'phone', 'email', 'status', 'source']
        },
        {
          model: Client,
          as: 'client',
          attributes: ['id', 'name', 'phone', 'email', 'status']
        },
        {
          model: User,
          as: 'assignedUser',
          attributes: ['id', 'name', 'email']
        },
        {
          model: User,
          as: 'creator',
          attributes: ['id', 'name', 'email']
        }
      ]
    });

    if (!followUp) {
      return res.status(404).json({
        success: false,
        message: 'Ø§Ù„Ù…ØªØ§Ø¨Ø¹Ø© ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯Ø©'
      });
    }

    // ÙØ­Øµ ØµÙ„Ø§Ø­ÙŠØ© Ø§Ù„ÙˆØµÙˆÙ„
    const userRole = req.user.role;
    if ((userRole === 'sales' || userRole === 'sales_agent') && 
        followUp.assignedTo !== req.user.id) {
      return res.status(403).json({
        success: false,
        message: 'Ù„ÙŠØ³ Ù„Ø¯ÙŠÙƒ ØµÙ„Ø§Ø­ÙŠØ© Ù„Ø¹Ø±Ø¶ Ù‡Ø°Ù‡ Ø§Ù„Ù…ØªØ§Ø¨Ø¹Ø©'
      });
    }

    console.log('âœ… Follow-up found');

    res.json({
      success: true,
      data: followUp
    });

  } catch (error) {
    console.error('âŒ Error fetching follow-up:', error);
    res.status(500).json({
      success: false,
      message: 'Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø¬Ù„Ø¨ Ø§Ù„Ù…ØªØ§Ø¨Ø¹Ø©',
      error: error.message
    });
  }
};

// ØªØ­Ø¯ÙŠØ« Ù…ØªØ§Ø¨Ø¹Ø©
exports.updateFollowUp = async (req, res) => {
  try {
    const { id } = req.params;
    console.log('ğŸ“ Updating follow-up:', id, req.body);

    const followUp = await FollowUp.findByPk(id);

    if (!followUp) {
      return res.status(404).json({
        success: false,
        message: 'Ø§Ù„Ù…ØªØ§Ø¨Ø¹Ø© ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯Ø©'
      });
    }

    // ÙØ­Øµ ØµÙ„Ø§Ø­ÙŠØ© Ø§Ù„ØªØ­Ø¯ÙŠØ«
    const userRole = req.user.role;
    if ((userRole === 'sales' || userRole === 'sales_agent') && 
        followUp.assignedTo !== req.user.id && 
        followUp.createdBy !== req.user.id) {
      return res.status(403).json({
        success: false,
        message: 'Ù„ÙŠØ³ Ù„Ø¯ÙŠÙƒ ØµÙ„Ø§Ø­ÙŠØ© Ù„ØªØ¹Ø¯ÙŠÙ„ Ù‡Ø°Ù‡ Ø§Ù„Ù…ØªØ§Ø¨Ø¹Ø©'
      });
    }

    const {
      title,
      description,
      scheduledDate,
      status,
      priority,
      type,
      leadId,
      clientId,
      assignedTo,
      notes,
      result,
      reminderBefore
    } = req.body;

    // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØµØ­Ø© leadId Ø¥Ø°Ø§ ØªÙ… ØªÙ…Ø±ÙŠØ±Ù‡
    if (leadId && leadId !== followUp.leadId) {
      const lead = await Lead.findByPk(leadId);
      if (!lead) {
        return res.status(400).json({
          success: false,
          message: 'Ø§Ù„Ø¹Ù…ÙŠÙ„ Ø§Ù„Ù…Ø­ØªÙ…Ù„ ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯'
        });
      }
    }

    // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØµØ­Ø© clientId Ø¥Ø°Ø§ ØªÙ… ØªÙ…Ø±ÙŠØ±Ù‡
    if (clientId && clientId !== followUp.clientId) {
      const client = await Client.findByPk(clientId);
      if (!client) {
        return res.status(400).json({
          success: false,
          message: 'Ø§Ù„Ø¹Ù…ÙŠÙ„ ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯'
        });
      }
    }

    // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØµØ­Ø© assignedTo Ø¥Ø°Ø§ ØªÙ… ØªÙ…Ø±ÙŠØ±Ù‡
    if (assignedTo && assignedTo !== followUp.assignedTo) {
      const assignedUser = await User.findByPk(assignedTo);
      if (!assignedUser) {
        return res.status(400).json({
          success: false,
          message: 'Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø§Ù„Ù…Ø®ØµØµ ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯'
        });
      }
    }

    // ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
    const updateData = {};
    if (title !== undefined) updateData.title = title;
    if (description !== undefined) updateData.description = description;
    if (scheduledDate !== undefined) updateData.scheduledDate = new Date(scheduledDate);
    if (status !== undefined) updateData.status = status;
    if (priority !== undefined) updateData.priority = priority;
    if (type !== undefined) updateData.type = type;
    if (leadId !== undefined) updateData.leadId = leadId;
    if (clientId !== undefined) updateData.clientId = clientId;
    if (assignedTo !== undefined) updateData.assignedTo = assignedTo;
    if (notes !== undefined) updateData.notes = notes;
    if (result !== undefined) updateData.result = result;
    if (reminderBefore !== undefined) updateData.reminderBefore = reminderBefore;

    await followUp.update(updateData);

    // Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„ØªØ°ÙƒÙŠØ±Ø§Øª
    if (reminderBefore !== undefined) {
      try {
        // Ø¥Ø²Ø§Ù„Ø© Ø§Ù„ØªØ°ÙƒÙŠØ± Ø§Ù„Ù‚Ø¯ÙŠÙ… Ø£ÙˆÙ„Ø§Ù‹
        await FollowUpIntegrationService.removeReminderForFollowUp(id);
        
        // Ø¥Ù†Ø´Ø§Ø¡ ØªØ°ÙƒÙŠØ± Ø¬Ø¯ÙŠØ¯ Ø¥Ø°Ø§ ØªÙ… ØªØ­Ø¯ÙŠØ¯ Ù‚ÙŠÙ…Ø©
        if (reminderBefore && reminderBefore > 0) {
          await FollowUpIntegrationService.createReminderForFollowUp(followUp, reminderBefore);
        }
      } catch (reminderError) {
        console.warn('âš ï¸ Failed to update reminder:', reminderError.message);
      }
    }

    // Ø¬Ù„Ø¨ Ø§Ù„Ù…ØªØ§Ø¨Ø¹Ø© Ø§Ù„Ù…Ø­Ø¯Ø«Ø© Ù…Ø¹ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„ÙƒØ§Ù…Ù„Ø©
    const updatedFollowUp = await FollowUp.findByPk(id, {
      include: [
        {
          model: Lead,
          as: 'lead',
          attributes: ['id', 'name', 'phone', 'email']
        },
        {
          model: Client,
          as: 'client',
          attributes: ['id', 'name', 'phone', 'email']
        },
        {
          model: User,
          as: 'assignedUser',
          attributes: ['id', 'name', 'email']
        },
        {
          model: User,
          as: 'creator',
          attributes: ['id', 'name', 'email']
        }
      ]
    });

    console.log('âœ… Follow-up updated successfully');

    res.json({
      success: true,
      message: 'ØªÙ… ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù…ØªØ§Ø¨Ø¹Ø© Ø¨Ù†Ø¬Ø§Ø­',
      data: updatedFollowUp
    });

  } catch (error) {
    console.error('âŒ Error updating follow-up:', error);
    res.status(500).json({
      success: false,
      message: 'Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù…ØªØ§Ø¨Ø¹Ø©',
      error: error.message
    });
  }
};

// Ø­Ø°Ù Ù…ØªØ§Ø¨Ø¹Ø© (soft delete)
exports.deleteFollowUp = async (req, res) => {
  try {
    const { id } = req.params;
    console.log('ğŸ—‘ï¸ Deleting follow-up:', id);

    const followUp = await FollowUp.findByPk(id);

    if (!followUp) {
      return res.status(404).json({
        success: false,
        message: 'Ø§Ù„Ù…ØªØ§Ø¨Ø¹Ø© ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯Ø©'
      });
    }

    // ÙØ­Øµ ØµÙ„Ø§Ø­ÙŠØ© Ø§Ù„Ø­Ø°Ù
    const userRole = req.user.role;
    if ((userRole === 'sales' || userRole === 'sales_agent') && 
        followUp.assignedTo !== req.user.id && 
        followUp.createdBy !== req.user.id) {
      return res.status(403).json({
        success: false,
        message: 'Ù„ÙŠØ³ Ù„Ø¯ÙŠÙƒ ØµÙ„Ø§Ø­ÙŠØ© Ù„Ø­Ø°Ù Ù‡Ø°Ù‡ Ø§Ù„Ù…ØªØ§Ø¨Ø¹Ø©'
      });
    }

    const followUpTitle = followUp.title;

    // ØªØ­Ø¯ÙŠØ« Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ø­Ø°Ù Ù‚Ø¨Ù„ Ø§Ù„Ø­Ø°Ù Ø§Ù„Ù†Ø§Ø¹Ù…
    await followUp.update({
      deleted_by: req.user.id
    });

    // Ø¥Ø²Ø§Ù„Ø© Ø§Ù„ØªØ°ÙƒÙŠØ±Ø§Øª Ø§Ù„Ù…Ø±ØªØ¨Ø·Ø©
    await FollowUpIntegrationService.removeReminderForFollowUp(id);

    // Ø­Ø°Ù Ù†Ø§Ø¹Ù…
    await followUp.destroy();

    console.log(`ğŸ—‘ï¸ Follow-up soft deleted: ${followUpTitle} by ${req.user.name}`);

    res.json({
      success: true,
      message: 'ØªÙ… Ø­Ø°Ù Ø§Ù„Ù…ØªØ§Ø¨Ø¹Ø©'
    });

  } catch (error) {
    console.error('âŒ Error deleting follow-up:', error);
    res.status(500).json({
      success: false,
      message: 'Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø­Ø°Ù Ø§Ù„Ù…ØªØ§Ø¨Ø¹Ø©',
      error: error.message
    });
  }
};

// Ø­Ø°Ù Ù…ØªØ§Ø¨Ø¹Ø© Ù†Ù‡Ø§Ø¦ÙŠØ§Ù‹
exports.permanentDeleteFollowUp = async (req, res) => {
  try {
    const { id } = req.params;
    console.log('ğŸ—‘ï¸ Permanently deleting follow-up:', id);

    // Find the soft-deleted follow-up
    const followUp = await FollowUp.findByPk(id, { paranoid: false });

    if (!followUp) {
      return res.status(404).json({
        success: false,
        message: 'Ø§Ù„Ù…ØªØ§Ø¨Ø¹Ø© ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯Ø©'
      });
    }

    // Check if it's already soft deleted
    if (!followUp.deleted_at) {
      return res.status(400).json({
        success: false,
        message: 'ÙŠØ¬Ø¨ Ø£Ø±Ø´ÙØ© Ø§Ù„Ù…ØªØ§Ø¨Ø¹Ø© Ø£ÙˆÙ„Ø§Ù‹ Ù‚Ø¨Ù„ Ø§Ù„Ø­Ø°Ù Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠ'
      });
    }

    const followUpTitle = followUp.title;

    // Remove related reminders first
    await FollowUpIntegrationService.removeReminderForFollowUp(id);

    // Permanently delete
    await followUp.destroy({ force: true });

    console.log(`âš ï¸ Follow-up permanently deleted: ${followUpTitle} by ${req.user?.name || 'system'}`);

    res.json({
      success: true,
      message: 'ØªÙ… Ø­Ø°Ù Ø§Ù„Ù…ØªØ§Ø¨Ø¹Ø© Ù†Ù‡Ø§Ø¦ÙŠØ§Ù‹'
    });

  } catch (error) {
    console.error('âŒ Error permanently deleting follow-up:', error);
    res.status(500).json({
      success: false,
      message: 'Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ø­Ø°Ù Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠ Ù„Ù„Ù…ØªØ§Ø¨Ø¹Ø©',
      error: error.message
    });
  }
};

// Ø§Ø³ØªØ¹Ø§Ø¯Ø© Ù…ØªØ§Ø¨Ø¹Ø© Ù…Ø­Ø°ÙˆÙØ©
exports.restoreFollowUp = async (req, res) => {
  try {
    const { id } = req.params;
    console.log('â™»ï¸ Restoring follow-up:', id);

    // Find the soft-deleted follow-up
    const followUp = await FollowUp.findByPk(id, { paranoid: false });

    if (!followUp) {
      return res.status(404).json({
        success: false,
        message: 'Ø§Ù„Ù…ØªØ§Ø¨Ø¹Ø© ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯Ø©'
      });
    }

    if (!followUp.deleted_at) {
      return res.status(400).json({
        success: false,
        message: 'Ø§Ù„Ù…ØªØ§Ø¨Ø¹Ø© ØºÙŠØ± Ù…Ø£Ø±Ø´ÙØ©'
      });
    }

    // Restore the follow-up
    await followUp.restore();

    console.log('âœ… Follow-up restored successfully');

    res.json({
      success: true,
      message: 'ØªÙ… Ø§Ø³ØªØ¹Ø§Ø¯Ø© Ø§Ù„Ù…ØªØ§Ø¨Ø¹Ø© Ø¨Ù†Ø¬Ø§Ø­',
      data: followUp
    });

  } catch (error) {
    console.error('âŒ Error restoring follow-up:', error);
    res.status(500).json({
      success: false,
      message: 'Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ø³ØªØ¹Ø§Ø¯Ø© Ø§Ù„Ù…ØªØ§Ø¨Ø¹Ø©',
      error: error.message
    });
  }
};

// Ø¬Ù„Ø¨ Ø§Ù„Ù…ØªØ§Ø¨Ø¹Ø§Øª Ø§Ù„Ù…Ø£Ø±Ø´ÙØ©
exports.getArchivedFollowUps = async (req, res) => {
  try {
    const {
      page = 1,
      limit = 20,
      search
    } = req.query;

    const offset = (page - 1) * limit;
    const where = {};

    // Ø§Ù„Ø¨Ø­Ø« Ø§Ù„Ù†ØµÙŠ
    if (search) {
      where[Op.or] = [
        { title: { [Op.iLike]: `%${search}%` } },
        { description: { [Op.iLike]: `%${search}%` } },
        { notes: { [Op.iLike]: `%${search}%` } }
      ];
    }

    const followUps = await FollowUp.findAndCountAll({
      where: {
        ...where,
        deleted_at: {
          [Op.not]: null // Only get deleted records
        }
      },
      include: [
        {
          model: Lead,
          as: 'lead',
          attributes: ['id', 'name', 'phone', 'email'],
          paranoid: false // Include deleted leads
        },
        {
          model: Client,
          as: 'client',
          attributes: ['id', 'name', 'phone', 'email'],
          paranoid: false // Include deleted clients
        },
        {
          model: User,
          as: 'assignedUser',
          attributes: ['id', 'name', 'email']
        },
        {
          model: User,
          as: 'creator',
          attributes: ['id', 'name', 'email']
        },
        {
          model: User,
          as: 'deletedByUser',
          attributes: ['id', 'name', 'username', 'email'],
          required: false
        }
      ],
      order: [['deleted_at', 'DESC']],
      limit: parseInt(limit),
      offset: parseInt(offset),
      distinct: true,
      paranoid: false // Include soft-deleted records
    });

    console.log(`âœ… Found ${followUps.count} archived follow-ups`);

    res.json({
      success: true,
      data: followUps.rows,
      pagination: {
        currentPage: parseInt(page),
        totalPages: Math.ceil(followUps.count / limit),
        totalItems: followUps.count,
        itemsPerPage: parseInt(limit),
        hasNextPage: page < Math.ceil(followUps.count / limit),
        hasPrevPage: page > 1
      }
    });

  } catch (error) {
    console.error('âŒ Error getting archived follow-ups:', error);
    res.status(500).json({
      success: false,
      message: 'Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø¬Ù„Ø¨ Ø§Ù„Ù…ØªØ§Ø¨Ø¹Ø§Øª Ø§Ù„Ù…Ø£Ø±Ø´ÙØ©',
      error: error.message
    });
  }
};

// Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ù…ØªØ§Ø¨Ø¹Ø§Øª
exports.getFollowUpStats = async (req, res) => {
  try {
    console.log('ğŸ“Š Getting follow-up statistics for user:', req.user.id);

    const today = new Date();
    const startOfDay = new Date(today.setHours(0, 0, 0, 0));
    const endOfDay = new Date(today.setHours(23, 59, 59, 999));
    const startOfWeek = new Date(today.getTime() - 7 * 24 * 60 * 60 * 1000);

    const [
      todayTotal,
      todayCompleted,
      weeklyTotal,
      weeklyCompleted,
      overdue,
      byStatus,
      byType,
      byPriority,
      autoGenerated,
      manual
    ] = await Promise.all([
      // Ù…ØªØ§Ø¨Ø¹Ø§Øª Ø§Ù„ÙŠÙˆÙ…
      FollowUp.count({
        where: {
          assignedTo: req.user.id,
          scheduledDate: { [Op.between]: [startOfDay, endOfDay] }
        }
      }),
      // Ù…ÙƒØªÙ…Ù„Ø© Ø§Ù„ÙŠÙˆÙ…
      FollowUp.count({
        where: {
          assignedTo: req.user.id,
          scheduledDate: { [Op.between]: [startOfDay, endOfDay] },
          status: 'done'
        }
      }),
      // Ù…ØªØ§Ø¨Ø¹Ø§Øª Ø§Ù„Ø£Ø³Ø¨ÙˆØ¹
      FollowUp.count({
        where: {
          assignedTo: req.user.id,
          scheduledDate: { [Op.gte]: startOfWeek }
        }
      }),
      // Ù…ÙƒØªÙ…Ù„Ø© Ø§Ù„Ø£Ø³Ø¨ÙˆØ¹
      FollowUp.count({
        where: {
          assignedTo: req.user.id,
          scheduledDate: { [Op.gte]: startOfWeek },
          status: 'done'
        }
      }),
      // Ù…ØªØ£Ø®Ø±Ø©
      FollowUp.count({
        where: {
          assignedTo: req.user.id,
          scheduledDate: { [Op.lt]: new Date() },
          status: { [Op.not]: 'done' }
        }
      }),
      // Ø­Ø³Ø¨ Ø§Ù„Ø­Ø§Ù„Ø©
      FollowUp.findAll({
        attributes: [
          'status',
          [FollowUp.sequelize.fn('COUNT', '*'), 'count']
        ],
        where: { assignedTo: req.user.id },
        group: 'status'
      }),
      // Ø­Ø³Ø¨ Ø§Ù„Ù†ÙˆØ¹
      FollowUp.findAll({
        attributes: [
          'type',
          [FollowUp.sequelize.fn('COUNT', '*'), 'count']
        ],
        where: { assignedTo: req.user.id },
        group: 'type'
      }),
      // Ø­Ø³Ø¨ Ø§Ù„Ø£ÙˆÙ„ÙˆÙŠØ©
      FollowUp.findAll({
        attributes: [
          'priority',
          [FollowUp.sequelize.fn('COUNT', '*'), 'count']
        ],
        where: { assignedTo: req.user.id },
        group: 'priority'
      }),
      // Ø§Ù„Ù…ØªØ§Ø¨Ø¹Ø§Øª Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠØ©
      FollowUp.count({
        where: {
          assignedTo: req.user.id,
          isAutoGenerated: true
        }
      }),
      // Ø§Ù„Ù…ØªØ§Ø¨Ø¹Ø§Øª Ø§Ù„ÙŠØ¯ÙˆÙŠØ©
      FollowUp.count({
        where: {
          assignedTo: req.user.id,
          isAutoGenerated: false
        }
      })
    ]);

    const stats = {
      today: {
        total: todayTotal,
        completed: todayCompleted,
        pending: todayTotal - todayCompleted,
        completionRate: todayTotal > 0 ? Math.round((todayCompleted / todayTotal) * 100) : 0
      },
      weekly: {
        total: weeklyTotal,
        completed: weeklyCompleted,
        pending: weeklyTotal - weeklyCompleted,
        completionRate: weeklyTotal > 0 ? Math.round((weeklyCompleted / weeklyTotal) * 100) : 0
      },
      overdue,
      automation: {
        autoGenerated,
        manual,
        autoPercentage: (autoGenerated + manual) > 0 ? Math.round((autoGenerated / (autoGenerated + manual)) * 100) : 0
      },
      byStatus: byStatus.reduce((acc, item) => {
        acc[item.status] = parseInt(item.dataValues.count);
        return acc;
      }, {}),
      byType: byType.reduce((acc, item) => {
        acc[item.type] = parseInt(item.dataValues.count);
        return acc;
      }, {}),
      byPriority: byPriority.reduce((acc, item) => {
        acc[item.priority] = parseInt(item.dataValues.count);
        return acc;
      }, {})
    };

    console.log('âœ… Follow-up statistics calculated');

    res.json({
      success: true,
      data: stats
    });

  } catch (error) {
    console.error('âŒ Error getting follow-up statistics:', error);
    res.status(500).json({
      success: false,
      message: 'Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø¬Ù„Ø¨ Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ù…ØªØ§Ø¨Ø¹Ø§Øª',
      error: error.message
    });
  }
};
// ØªØ´ØºÙŠÙ„ Ø§Ù„Ù…ØªØ§Ø¨Ø¹Ø§Øª Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠØ© Ø§Ù„Ø¯ÙˆØ±ÙŠØ© (ÙŠÙ…ÙƒÙ† Ø§Ø³ØªØ¯Ø¹Ø§Ø¤Ù‡Ø§ Ù…Ù† cron job)
exports.runAutomaticFollowUps = async (req, res) => {
  try {
    console.log('ğŸ¤– Running automatic follow-up scheduling...');

    await AutoFollowUpService.scheduleAutomaticFollowUps();

    res.json({
      success: true,
      message: 'ØªÙ… ØªØ´ØºÙŠÙ„ Ø§Ù„Ù…ØªØ§Ø¨Ø¹Ø§Øª Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠØ© Ø¨Ù†Ø¬Ø§Ø­'
    });

  } catch (error) {
    console.error('âŒ Error running automatic follow-ups:', error);
    res.status(500).json({
      success: false,
      message: 'Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ ØªØ´ØºÙŠÙ„ Ø§Ù„Ù…ØªØ§Ø¨Ø¹Ø§Øª Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠØ©',
      error: error.message
    });
  }
};

// ØªÙˆØ²ÙŠØ¹ Ù…ØªØ§Ø¨Ø¹Ø§Øª Ù„Ù„Ø¹Ù…Ù„Ø§Ø¡ Ø§Ù„Ù…Ø­ØªÙ…Ù„ÙŠÙ† Ø§Ù„Ù…ÙˆØ²Ø¹ÙŠÙ†
exports.distributeFollowUps = async (req, res) => {
  try {
    console.log('ğŸ¯ Distributing follow-ups for assigned leads...');
    
    const { followUpAssignments, createdBy } = req.body;
    
    if (!followUpAssignments || !Array.isArray(followUpAssignments)) {
      return res.status(400).json({
        success: false,
        message: 'ÙŠØ¬Ø¨ ØªÙ…Ø±ÙŠØ± Ù‚Ø§Ø¦Ù…Ø© ØªØ®ØµÙŠØµØ§Øª Ø§Ù„Ù…ØªØ§Ø¨Ø¹Ø©'
      });
    }
    
    const results = await AutoFollowUpService.distributeFollowUpsWithLeads(
      followUpAssignments,
      createdBy || req.user.id
    );
    
    res.json({
      success: true,
      message: 'ØªÙ… ØªÙˆØ²ÙŠØ¹ Ø§Ù„Ù…ØªØ§Ø¨Ø¹Ø§Øª Ø¨Ù†Ø¬Ø§Ø­',
      data: results
    });
    
  } catch (error) {
    console.error('âŒ Error distributing follow-ups:', error);
    res.status(500).json({
      success: false,
      message: 'Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ ØªÙˆØ²ÙŠØ¹ Ø§Ù„Ù…ØªØ§Ø¨Ø¹Ø§Øª',
      error: error.message
    });
  }
};

// Ø¥Ù†Ø´Ø§Ø¡ Ù…ØªØ§Ø¨Ø¹Ø§Øª ØªÙ„Ù‚Ø§Ø¦ÙŠØ© Ù„Ø¹Ù…ÙŠÙ„ Ù…Ø­ØªÙ…Ù„
exports.createAutoLeadFollowUps = async (req, res) => {
  try {
    console.log('ğŸ¤– Creating auto follow-ups for lead...');
    
    const { leadId, assignedTo } = req.body;
    
    if (!leadId || !assignedTo) {
      return res.status(400).json({
        success: false,
        message: 'ÙŠØ¬Ø¨ ØªÙ…Ø±ÙŠØ± Ù…Ø¹Ø±Ù Ø§Ù„Ø¹Ù…ÙŠÙ„ Ø§Ù„Ù…Ø­ØªÙ…Ù„ ÙˆØ§Ù„Ù…ÙˆØ¸Ù Ø§Ù„Ù…Ø®ØµØµ'
      });
    }
    
    const followUps = await AutoFollowUpService.createLeadFollowUps(leadId, assignedTo, req.user.id);
    
    res.json({
      success: true,
      message: 'ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù…ØªØ§Ø¨Ø¹Ø§Øª Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠØ© Ø¨Ù†Ø¬Ø§Ø­',
      data: followUps
    });
    
  } catch (error) {
    console.error('âŒ Error creating auto lead follow-ups:', error);
    res.status(500).json({
      success: false,
      message: 'Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù…ØªØ§Ø¨Ø¹Ø§Øª Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠØ©',
      error: error.message
    });
  }
};

// Complete a follow-up
exports.completeFollowUp = async (req, res) => {
  try {
    const { id } = req.params;
    const { notes, outcome, next_action } = req.body;

    // Ø¬Ù„Ø¨ Ø§Ù„Ù…ØªØ§Ø¨Ø¹Ø© Ù…Ø¹ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø±ØªØ¨Ø·Ø©
    const followUp = await FollowUp.findByPk(id, {
      include: [
        {
          model: Lead,
          as: 'lead',
          attributes: ['id', 'name', 'phone', 'email']
        },
        {
          model: Client,
          as: 'client', 
          attributes: ['id', 'name', 'phone', 'email']
        }
      ]
    });

    if (!followUp) {
      return res.status(404).json({
        success: false,
        message: 'Ù…ØªØ§Ø¨Ø¹Ø© ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯Ø©'
      });
    }

    console.log(`âœ… Completing follow-up ${id} with outcome: ${outcome}`);

    // Update follow-up status to done
    await followUp.update({
      status: 'done',
      completedDate: new Date(),
      notes: notes || followUp.notes,
      actualOutcome: outcome || followUp.actualOutcome,
      nextAction: next_action || followUp.nextAction
    });

    let nextFollowUp = null;

    // Ø¥Ù†Ø´Ø§Ø¡ Ù…ØªØ§Ø¨Ø¹Ø© ØªØ§Ù„ÙŠØ© Ø¥Ø°Ø§ ØªÙ… ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ù†ØªÙŠØ¬Ø©
    if (outcome && outcome !== 'not_interested') {
      try {
        nextFollowUp = await AutoFollowUpService.createNextFollowUp(
          followUp,
          outcome,
          next_action,
          followUp.assignedTo,
          req.user.id
        );
        
        if (nextFollowUp) {
          console.log(`ğŸ¯ Next follow-up created: ${nextFollowUp.title}`);
        }
      } catch (error) {
        console.error('âš ï¸ Failed to create next follow-up:', error);
        // Ù„Ø§ Ù†ÙˆÙ‚Ù Ø§Ù„Ø¹Ù…Ù„ÙŠØ© Ø¥Ø°Ø§ ÙØ´Ù„Øª Ø§Ù„Ù…ØªØ§Ø¨Ø¹Ø© Ø§Ù„ØªØ§Ù„ÙŠØ©
      }
    }

    res.json({
      success: true,
      message: 'ØªÙ… Ø¥ØªÙ…Ø§Ù… Ø§Ù„Ù…ØªØ§Ø¨Ø¹Ø© Ø¨Ù†Ø¬Ø§Ø­',
      data: {
        completedFollowUp: followUp,
        nextFollowUp: nextFollowUp
      }
    });
  } catch (error) {
    console.error('Error completing follow-up:', error);
    res.status(500).json({
      success: false,
      message: 'Ø®Ø·Ø£ ÙÙŠ Ø¥ØªÙ…Ø§Ù… Ø§Ù„Ù…ØªØ§Ø¨Ø¹Ø©'
    });
  }
};

// Get today's follow-ups for current user
exports.getTodayFollowUps = async (req, res) => {
  try {
    const today = new Date();
    const startOfDay = new Date(today.setHours(0, 0, 0, 0));
    const endOfDay = new Date(today.setHours(23, 59, 59, 999));

    const whereConditions = {
      scheduledDate: {
        [Op.between]: [startOfDay, endOfDay]
      },
      status: {
        [Op.in]: ['scheduled', 'rescheduled']
      }
    };

    // ÙÙ„ØªØ±Ø© Ø­Ø³Ø¨ Ø§Ù„Ø¯ÙˆØ±
    const userRole = req.user.role;
    if (userRole === 'sales' || userRole === 'sales_agent') {
      // Ù…ÙˆØ¸ÙÙŠ Ø§Ù„Ù…Ø¨ÙŠØ¹Ø§Øª ÙŠØ±ÙˆÙ† Ù…ØªØ§Ø¨Ø¹Ø§ØªÙ‡Ù… ÙÙ‚Ø·
      // ØªØ­ÙˆÙŠÙ„ Ù„Ù€ number Ù„Ù„ØªØ£ÙƒØ¯ Ù…Ù† Ø§Ù„ØªØ·Ø§Ø¨Ù‚ Ù…Ø¹ assignedTo ÙÙŠ database
      whereConditions.assignedTo = parseInt(req.user.id);
    }
    // Ø§Ù„Ù…Ø¯ÙŠØ± ÙˆØ§Ù„Ø£Ø¯Ù…Ù† ÙŠØ±ÙˆÙ† Ø¬Ù…ÙŠØ¹ Ù…ØªØ§Ø¨Ø¹Ø§Øª Ø§Ù„ÙŠÙˆÙ…

    const followUps = await FollowUp.findAll({
      where: whereConditions,
      include: [
        {
          model: Client,
          as: 'client',
          attributes: ['id', 'name', 'email', 'phone'],
          required: false
        },
        {
          model: Lead,
          as: 'lead', 
          attributes: ['id', 'name', 'email', 'phone', 'status'],
          required: false
        }
      ],
      order: [['scheduledDate', 'ASC']],
      limit: 10
    });

    res.json({
      success: true,
      data: followUps,
      count: followUps.length
    });
  } catch (error) {
    console.error('Error fetching today follow-ups:', error);
    res.status(500).json({
      success: false,
      message: 'Ø®Ø·Ø£ ÙÙŠ Ø¬Ù„Ø¨ Ù…ØªØ§Ø¨Ø¹Ø§Øª Ø§Ù„ÙŠÙˆÙ…',
      error: error.message
    });
  }
};

// Delete all archived follow-ups permanently
exports.permanentDeleteAllFollowUps = async (req, res) => {
  try {
    console.log('ğŸ—‘ï¸ Permanently deleting all archived follow-ups');

    // Find all soft-deleted follow-ups
    const archivedFollowUps = await FollowUp.findAll({ 
      paranoid: false,
      where: {
        deleted_at: {
          [Op.not]: null
        }
      }
    });

    if (archivedFollowUps.length === 0) {
      return res.status(200).json({
        success: true,
        message: 'No archived follow-ups found to delete',
        deletedCount: 0
      });
    }

    const count = archivedFollowUps.length;

    // Remove related reminders for all archived follow-ups
    for (const followUp of archivedFollowUps) {
      await FollowUpIntegrationService.removeReminderForFollowUp(followUp.id);
    }
    
    // Permanently delete all archived follow-ups
    await FollowUp.destroy({ 
      force: true,
      paranoid: false,
      where: {
        deleted_at: {
          [Op.not]: null
        }
      }
    });

    console.log(`âš ï¸ ${count} follow-ups permanently deleted by ${req.user?.name || 'system'}`);

    res.json({
      success: true,
      message: `ØªÙ… Ø­Ø°Ù ${count} Ù…ØªØ§Ø¨Ø¹Ø© Ù†Ù‡Ø§Ø¦ÙŠØ§Ù‹`,
      deletedCount: count
    });

  } catch (error) {
    console.error('âŒ Error permanently deleting all follow-ups:', error);
    res.status(500).json({
      success: false,
      message: 'Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„Ø­Ø°Ù Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠ Ù„Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù…ØªØ§Ø¨Ø¹Ø§Øª',
      error: error.message
    });
  }
};