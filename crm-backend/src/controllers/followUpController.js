const { FollowUp, Lead, Client, User, sequelize } = require('../../models');
const { body, validationResult, query } = require('express-validator');
const { Op } = require('sequelize');
const AutoFollowUpService = require('../services/autoFollowUpService');
const FollowUpIntegrationService = require('../services/followUpIntegrationService');

// إنشاء متابعة جديدة
exports.createFollowUp = async (req, res) => {
  try {
    console.log('📝 Creating new follow-up:', req.body);

    const {
      title,
      description,
      scheduledDate,
      status = 'pending',
      priority = 'medium',
      type = 'call',
      leadId,
      clientId,
      assignedTo,
      notes,
      reminderBefore
    } = req.body;

    // التحقق من وجود الحقول المطلوبة
    if (!title || !scheduledDate) {
      return res.status(400).json({
        success: false,
        message: 'العنوان وتاريخ الجدولة مطلوبان'
      });
    }

    // التحقق من وجود leadId أو clientId
    if (!leadId && !clientId) {
      return res.status(400).json({
        success: false,
        message: 'يجب تحديد عميل محتمل أو عميل'
      });
    }

    // التحقق من صحة assignedTo
    if (assignedTo) {
      const assignedUser = await User.findByPk(assignedTo);
      if (!assignedUser) {
        return res.status(400).json({
          success: false,
          message: 'المستخدم المخصص غير موجود'
        });
      }
    }

    // التحقق من صحة leadId إذا تم تمريره
    if (leadId) {
      const lead = await Lead.findByPk(leadId);
      if (!lead) {
        return res.status(400).json({
          success: false,
          message: 'العميل المحتمل غير موجود'
        });
      }
    }

    // التحقق من صحة clientId إذا تم تمريره
    if (clientId) {
      const client = await Client.findByPk(clientId);
      if (!client) {
        console.error(`❌ Client ID ${clientId} not found in database`);
        return res.status(400).json({
          success: false,
          message: `العميل رقم ${clientId} غير موجود في قاعدة البيانات`
        });
      }
    }

    // إنشاء المتابعة
    const followUp = await FollowUp.create({
      title,
      description,
      scheduledDate: new Date(scheduledDate),
      status,
      priority,
      type,
      leadId: leadId || null,
      clientId: clientId || null,
      assignedTo: assignedTo || req.user.id,
      createdBy: req.user.id,
      notes,
      reminderBefore
    });

    // إنشاء تذكير إذا تم تحديد reminderBefore
    if (reminderBefore && reminderBefore > 0) {
      try {
        await FollowUpIntegrationService.createReminderForFollowUp(followUp);
        console.log('✅ Reminder created for follow-up');
      } catch (reminderError) {
        console.warn('⚠️ Failed to create reminder:', reminderError.message);
        // لا نريد فشل إنشاء المتابعة بسبب فشل في إنشاء التذكير
      }
    }

    // إرجاع المتابعة مباشرة بدون معقدات
    const fullFollowUp = followUp;

    console.log('✅ Follow-up created successfully');
    console.log('🔍 Follow-up details:', {
      id: followUp.id,
      title: title,
      clientId: clientId || 'none',
      leadId: leadId || 'none',
      assignedTo: assignedTo || req.user.id,
      createdBy: req.user.id,
      isAutoGenerated: followUp.isAutoGenerated || false
    });

    res.status(201).json({
      success: true,
      message: 'تم إنشاء المتابعة بنجاح',
      data: fullFollowUp
    });

  } catch (error) {
    console.error('❌ Error creating follow-up:', error);
    res.status(500).json({
      success: false,
      message: 'حدث خطأ أثناء إنشاء المتابعة',
      error: error.message
    });
  }
};

// جلب جميع المتابعات مع التصفية والترقيم
exports.getAllFollowUps = async (req, res) => {
  try {
    const {
      page = 1,
      limit = 20,
      status,
      priority,
      type,
      assignedTo,
      userFilter,
      search,
      startDate,
      endDate,
      overdue = false
    } = req.query;

    console.log('📋 Fetching follow-ups with filters:', req.query);

    const offset = (page - 1) * limit;
    const where = {};
    const include = [
      {
        model: Lead,
        as: 'lead',
        attributes: ['id', 'name', 'phone', 'email'],
        paranoid: false // Include deleted leads
      },
      {
        model: Client,
        as: 'client',
        attributes: ['id', 'name', 'phone', 'email'],
        paranoid: false // Include deleted clients
      },
      {
        model: User,
        as: 'assignedUser',
        attributes: ['id', 'name', 'email']
      },
      {
        model: User,
        as: 'creator',
        attributes: ['id', 'name', 'email']
      }
    ];

    // فلترة حسب الحالة
    if (status) {
      where.status = status;
    }

    // فلترة حسب الأولوية
    if (priority) {
      where.priority = priority;
    }

    // فلترة حسب النوع
    if (type) {
      where.type = type;
    }

    // فلترة حسب المخصص له
    if (assignedTo) {
      where.assignedTo = assignedTo;
    }

    // البحث النصي
    if (search) {
      where[Op.or] = [
        { title: { [Op.iLike]: `%${search}%` } },
        { description: { [Op.iLike]: `%${search}%` } },
        { notes: { [Op.iLike]: `%${search}%` } }
      ];
    }

    // فلترة شاملة بـ userFilter (مخصص له أو أنشأه) - فقط إذا لم يكن هناك بحث نصي
    if (userFilter && !search) {
      where[Op.or] = [
        { assignedTo: parseInt(userFilter) },
        { createdBy: parseInt(userFilter) }
      ];
    }

    // فلترة حسب التاريخ
    if (startDate || endDate) {
      where.scheduledDate = {};
      if (startDate) {
        where.scheduledDate[Op.gte] = new Date(startDate);
      }
      if (endDate) {
        where.scheduledDate[Op.lte] = new Date(endDate);
      }
    }

    // فلترة المتأخرة
    if (overdue === 'true') {
      where.scheduledDate = { [Op.lt]: new Date() };
      where.status = { [Op.not]: 'done' };
    }

    // إضافة فلترة دور المستخدم
    const userRole = req.user.role;
    if (userRole === 'sales' || userRole === 'sales_agent') {
      // موظفي المبيعات يرون المتابعات المخصصة لهم فقط
      // تحويل لـ number للتأكد من التطابق مع assignedTo في database
      where.assignedTo = parseInt(req.user.id);
    }
    // المدير والأدمن يرون جميع المتابعات (لا فلترة إضافية)

    const followUps = await FollowUp.findAndCountAll({
      where,
      include,
      order: [['scheduledDate', 'ASC'], ['priority', 'DESC']],
      limit: parseInt(limit),
      offset: parseInt(offset),
      distinct: true, // منع التكرار بسبب الـ joins المتعددة
      subQuery: false // تحسين الأداء مع الـ includes
    });

    // التحقق من وجود تكرار
    const uniqueIds = [...new Set(followUps.rows.map(f => f.id))];
    if (uniqueIds.length !== followUps.rows.length) {
      console.warn(`⚠️ DUPLICATES DETECTED! Unique IDs: ${uniqueIds.length}, Total rows: ${followUps.rows.length}`);
    }

    res.json({
      success: true,
      data: followUps.rows,
      pagination: {
        total: followUps.count,
        page: parseInt(page),
        limit: parseInt(limit),
        totalPages: Math.ceil(followUps.count / limit)
      }
    });

  } catch (error) {
    console.error('❌ Error fetching follow-ups:', error);
    res.status(500).json({
      success: false,
      message: 'حدث خطأ أثناء جلب المتابعات',
      error: error.message
    });
  }
};

// جلب متابعة واحدة
exports.getFollowUpById = async (req, res) => {
  try {
    const { id } = req.params;
    console.log('🔍 Fetching follow-up:', id);

    const followUp = await FollowUp.findByPk(id, {
      include: [
        {
          model: Lead,
          as: 'lead',
          attributes: ['id', 'name', 'phone', 'email', 'status', 'source']
        },
        {
          model: Client,
          as: 'client',
          attributes: ['id', 'name', 'phone', 'email', 'status']
        },
        {
          model: User,
          as: 'assignedUser',
          attributes: ['id', 'name', 'email']
        },
        {
          model: User,
          as: 'creator',
          attributes: ['id', 'name', 'email']
        }
      ]
    });

    if (!followUp) {
      return res.status(404).json({
        success: false,
        message: 'المتابعة غير موجودة'
      });
    }

    // فحص صلاحية الوصول
    const userRole = req.user.role;
    if ((userRole === 'sales' || userRole === 'sales_agent') && 
        followUp.assignedTo !== req.user.id) {
      return res.status(403).json({
        success: false,
        message: 'ليس لديك صلاحية لعرض هذه المتابعة'
      });
    }

    console.log('✅ Follow-up found');

    res.json({
      success: true,
      data: followUp
    });

  } catch (error) {
    console.error('❌ Error fetching follow-up:', error);
    res.status(500).json({
      success: false,
      message: 'حدث خطأ أثناء جلب المتابعة',
      error: error.message
    });
  }
};

// تحديث متابعة
exports.updateFollowUp = async (req, res) => {
  try {
    const { id } = req.params;
    console.log('📝 Updating follow-up:', id, req.body);

    const followUp = await FollowUp.findByPk(id);

    if (!followUp) {
      return res.status(404).json({
        success: false,
        message: 'المتابعة غير موجودة'
      });
    }

    // فحص صلاحية التحديث
    const userRole = req.user.role;
    if ((userRole === 'sales' || userRole === 'sales_agent') && 
        followUp.assignedTo !== req.user.id && 
        followUp.createdBy !== req.user.id) {
      return res.status(403).json({
        success: false,
        message: 'ليس لديك صلاحية لتعديل هذه المتابعة'
      });
    }

    const {
      title,
      description,
      scheduledDate,
      status,
      priority,
      type,
      leadId,
      clientId,
      assignedTo,
      notes,
      result,
      reminderBefore
    } = req.body;

    // التحقق من صحة leadId إذا تم تمريره
    if (leadId && leadId !== followUp.leadId) {
      const lead = await Lead.findByPk(leadId);
      if (!lead) {
        return res.status(400).json({
          success: false,
          message: 'العميل المحتمل غير موجود'
        });
      }
    }

    // التحقق من صحة clientId إذا تم تمريره
    if (clientId && clientId !== followUp.clientId) {
      const client = await Client.findByPk(clientId);
      if (!client) {
        return res.status(400).json({
          success: false,
          message: 'العميل غير موجود'
        });
      }
    }

    // التحقق من صحة assignedTo إذا تم تمريره
    if (assignedTo && assignedTo !== followUp.assignedTo) {
      const assignedUser = await User.findByPk(assignedTo);
      if (!assignedUser) {
        return res.status(400).json({
          success: false,
          message: 'المستخدم المخصص غير موجود'
        });
      }
    }

    // تحديث البيانات
    const updateData = {};
    if (title !== undefined) updateData.title = title;
    if (description !== undefined) updateData.description = description;
    if (scheduledDate !== undefined) updateData.scheduledDate = new Date(scheduledDate);
    if (status !== undefined) updateData.status = status;
    if (priority !== undefined) updateData.priority = priority;
    if (type !== undefined) updateData.type = type;
    if (leadId !== undefined) updateData.leadId = leadId;
    if (clientId !== undefined) updateData.clientId = clientId;
    if (assignedTo !== undefined) updateData.assignedTo = assignedTo;
    if (notes !== undefined) updateData.notes = notes;
    if (result !== undefined) updateData.result = result;
    if (reminderBefore !== undefined) updateData.reminderBefore = reminderBefore;

    await followUp.update(updateData);

    // إدارة التذكيرات
    if (reminderBefore !== undefined) {
      try {
        // إزالة التذكير القديم أولاً
        await FollowUpIntegrationService.removeReminderForFollowUp(id);
        
        // إنشاء تذكير جديد إذا تم تحديد قيمة
        if (reminderBefore && reminderBefore > 0) {
          await FollowUpIntegrationService.createReminderForFollowUp(followUp, reminderBefore);
        }
      } catch (reminderError) {
        console.warn('⚠️ Failed to update reminder:', reminderError.message);
      }
    }

    // جلب المتابعة المحدثة مع البيانات الكاملة
    const updatedFollowUp = await FollowUp.findByPk(id, {
      include: [
        {
          model: Lead,
          as: 'lead',
          attributes: ['id', 'name', 'phone', 'email']
        },
        {
          model: Client,
          as: 'client',
          attributes: ['id', 'name', 'phone', 'email']
        },
        {
          model: User,
          as: 'assignedUser',
          attributes: ['id', 'name', 'email']
        },
        {
          model: User,
          as: 'creator',
          attributes: ['id', 'name', 'email']
        }
      ]
    });

    console.log('✅ Follow-up updated successfully');

    res.json({
      success: true,
      message: 'تم تحديث المتابعة بنجاح',
      data: updatedFollowUp
    });

  } catch (error) {
    console.error('❌ Error updating follow-up:', error);
    res.status(500).json({
      success: false,
      message: 'حدث خطأ أثناء تحديث المتابعة',
      error: error.message
    });
  }
};

// حذف متابعة (soft delete)
exports.deleteFollowUp = async (req, res) => {
  try {
    const { id } = req.params;
    console.log('🗑️ Deleting follow-up:', id);

    const followUp = await FollowUp.findByPk(id);

    if (!followUp) {
      return res.status(404).json({
        success: false,
        message: 'المتابعة غير موجودة'
      });
    }

    // فحص صلاحية الحذف
    const userRole = req.user.role;
    if ((userRole === 'sales' || userRole === 'sales_agent') && 
        followUp.assignedTo !== req.user.id && 
        followUp.createdBy !== req.user.id) {
      return res.status(403).json({
        success: false,
        message: 'ليس لديك صلاحية لحذف هذه المتابعة'
      });
    }

    const followUpTitle = followUp.title;

    // تحديث معلومات الحذف قبل الحذف الناعم
    await followUp.update({
      deleted_by: req.user.id
    });

    // إزالة التذكيرات المرتبطة
    await FollowUpIntegrationService.removeReminderForFollowUp(id);

    // حذف ناعم
    await followUp.destroy();

    console.log(`🗑️ Follow-up soft deleted: ${followUpTitle} by ${req.user.name}`);

    res.json({
      success: true,
      message: 'تم حذف المتابعة'
    });

  } catch (error) {
    console.error('❌ Error deleting follow-up:', error);
    res.status(500).json({
      success: false,
      message: 'حدث خطأ أثناء حذف المتابعة',
      error: error.message
    });
  }
};

// حذف متابعة نهائياً
exports.permanentDeleteFollowUp = async (req, res) => {
  try {
    const { id } = req.params;
    console.log('🗑️ Permanently deleting follow-up:', id);

    // Find the soft-deleted follow-up
    const followUp = await FollowUp.findByPk(id, { paranoid: false });

    if (!followUp) {
      return res.status(404).json({
        success: false,
        message: 'المتابعة غير موجودة'
      });
    }

    // Check if it's already soft deleted
    if (!followUp.deleted_at) {
      return res.status(400).json({
        success: false,
        message: 'يجب أرشفة المتابعة أولاً قبل الحذف النهائي'
      });
    }

    const followUpTitle = followUp.title;

    // Remove related reminders first
    await FollowUpIntegrationService.removeReminderForFollowUp(id);

    // Permanently delete
    await followUp.destroy({ force: true });

    console.log(`⚠️ Follow-up permanently deleted: ${followUpTitle} by ${req.user?.name || 'system'}`);

    res.json({
      success: true,
      message: 'تم حذف المتابعة نهائياً'
    });

  } catch (error) {
    console.error('❌ Error permanently deleting follow-up:', error);
    res.status(500).json({
      success: false,
      message: 'حدث خطأ أثناء الحذف النهائي للمتابعة',
      error: error.message
    });
  }
};

// استعادة متابعة محذوفة
exports.restoreFollowUp = async (req, res) => {
  try {
    const { id } = req.params;
    console.log('♻️ Restoring follow-up:', id);

    // Find the soft-deleted follow-up
    const followUp = await FollowUp.findByPk(id, { paranoid: false });

    if (!followUp) {
      return res.status(404).json({
        success: false,
        message: 'المتابعة غير موجودة'
      });
    }

    if (!followUp.deleted_at) {
      return res.status(400).json({
        success: false,
        message: 'المتابعة غير مأرشفة'
      });
    }

    // Restore the follow-up
    await followUp.restore();

    console.log('✅ Follow-up restored successfully');

    res.json({
      success: true,
      message: 'تم استعادة المتابعة بنجاح',
      data: followUp
    });

  } catch (error) {
    console.error('❌ Error restoring follow-up:', error);
    res.status(500).json({
      success: false,
      message: 'حدث خطأ أثناء استعادة المتابعة',
      error: error.message
    });
  }
};

// جلب المتابعات المأرشفة
exports.getArchivedFollowUps = async (req, res) => {
  try {
    const {
      page = 1,
      limit = 20,
      search
    } = req.query;

    const offset = (page - 1) * limit;
    const where = {};

    // البحث النصي
    if (search) {
      where[Op.or] = [
        { title: { [Op.iLike]: `%${search}%` } },
        { description: { [Op.iLike]: `%${search}%` } },
        { notes: { [Op.iLike]: `%${search}%` } }
      ];
    }

    const followUps = await FollowUp.findAndCountAll({
      where: {
        ...where,
        deleted_at: {
          [Op.not]: null // Only get deleted records
        }
      },
      include: [
        {
          model: Lead,
          as: 'lead',
          attributes: ['id', 'name', 'phone', 'email'],
          paranoid: false // Include deleted leads
        },
        {
          model: Client,
          as: 'client',
          attributes: ['id', 'name', 'phone', 'email'],
          paranoid: false // Include deleted clients
        },
        {
          model: User,
          as: 'assignedUser',
          attributes: ['id', 'name', 'email']
        },
        {
          model: User,
          as: 'creator',
          attributes: ['id', 'name', 'email']
        },
        {
          model: User,
          as: 'deletedByUser',
          attributes: ['id', 'name', 'username', 'email'],
          required: false
        }
      ],
      order: [['deleted_at', 'DESC']],
      limit: parseInt(limit),
      offset: parseInt(offset),
      distinct: true,
      paranoid: false // Include soft-deleted records
    });

    console.log(`✅ Found ${followUps.count} archived follow-ups`);

    res.json({
      success: true,
      data: followUps.rows,
      pagination: {
        currentPage: parseInt(page),
        totalPages: Math.ceil(followUps.count / limit),
        totalItems: followUps.count,
        itemsPerPage: parseInt(limit),
        hasNextPage: page < Math.ceil(followUps.count / limit),
        hasPrevPage: page > 1
      }
    });

  } catch (error) {
    console.error('❌ Error getting archived follow-ups:', error);
    res.status(500).json({
      success: false,
      message: 'حدث خطأ أثناء جلب المتابعات المأرشفة',
      error: error.message
    });
  }
};

// إحصائيات المتابعات
exports.getFollowUpStats = async (req, res) => {
  try {
    console.log('📊 Getting follow-up statistics for user:', req.user.id);

    const today = new Date();
    const startOfDay = new Date(today.setHours(0, 0, 0, 0));
    const endOfDay = new Date(today.setHours(23, 59, 59, 999));
    const startOfWeek = new Date(today.getTime() - 7 * 24 * 60 * 60 * 1000);

    const [
      todayTotal,
      todayCompleted,
      weeklyTotal,
      weeklyCompleted,
      overdue,
      byStatus,
      byType,
      byPriority,
      autoGenerated,
      manual
    ] = await Promise.all([
      // متابعات اليوم
      FollowUp.count({
        where: {
          assignedTo: req.user.id,
          scheduledDate: { [Op.between]: [startOfDay, endOfDay] }
        }
      }),
      // مكتملة اليوم
      FollowUp.count({
        where: {
          assignedTo: req.user.id,
          scheduledDate: { [Op.between]: [startOfDay, endOfDay] },
          status: 'done'
        }
      }),
      // متابعات الأسبوع
      FollowUp.count({
        where: {
          assignedTo: req.user.id,
          scheduledDate: { [Op.gte]: startOfWeek }
        }
      }),
      // مكتملة الأسبوع
      FollowUp.count({
        where: {
          assignedTo: req.user.id,
          scheduledDate: { [Op.gte]: startOfWeek },
          status: 'done'
        }
      }),
      // متأخرة
      FollowUp.count({
        where: {
          assignedTo: req.user.id,
          scheduledDate: { [Op.lt]: new Date() },
          status: { [Op.not]: 'done' }
        }
      }),
      // حسب الحالة
      FollowUp.findAll({
        attributes: [
          'status',
          [FollowUp.sequelize.fn('COUNT', '*'), 'count']
        ],
        where: { assignedTo: req.user.id },
        group: 'status'
      }),
      // حسب النوع
      FollowUp.findAll({
        attributes: [
          'type',
          [FollowUp.sequelize.fn('COUNT', '*'), 'count']
        ],
        where: { assignedTo: req.user.id },
        group: 'type'
      }),
      // حسب الأولوية
      FollowUp.findAll({
        attributes: [
          'priority',
          [FollowUp.sequelize.fn('COUNT', '*'), 'count']
        ],
        where: { assignedTo: req.user.id },
        group: 'priority'
      }),
      // المتابعات التلقائية
      FollowUp.count({
        where: {
          assignedTo: req.user.id,
          isAutoGenerated: true
        }
      }),
      // المتابعات اليدوية
      FollowUp.count({
        where: {
          assignedTo: req.user.id,
          isAutoGenerated: false
        }
      })
    ]);

    const stats = {
      today: {
        total: todayTotal,
        completed: todayCompleted,
        pending: todayTotal - todayCompleted,
        completionRate: todayTotal > 0 ? Math.round((todayCompleted / todayTotal) * 100) : 0
      },
      weekly: {
        total: weeklyTotal,
        completed: weeklyCompleted,
        pending: weeklyTotal - weeklyCompleted,
        completionRate: weeklyTotal > 0 ? Math.round((weeklyCompleted / weeklyTotal) * 100) : 0
      },
      overdue,
      automation: {
        autoGenerated,
        manual,
        autoPercentage: (autoGenerated + manual) > 0 ? Math.round((autoGenerated / (autoGenerated + manual)) * 100) : 0
      },
      byStatus: byStatus.reduce((acc, item) => {
        acc[item.status] = parseInt(item.dataValues.count);
        return acc;
      }, {}),
      byType: byType.reduce((acc, item) => {
        acc[item.type] = parseInt(item.dataValues.count);
        return acc;
      }, {}),
      byPriority: byPriority.reduce((acc, item) => {
        acc[item.priority] = parseInt(item.dataValues.count);
        return acc;
      }, {})
    };

    console.log('✅ Follow-up statistics calculated');

    res.json({
      success: true,
      data: stats
    });

  } catch (error) {
    console.error('❌ Error getting follow-up statistics:', error);
    res.status(500).json({
      success: false,
      message: 'حدث خطأ أثناء جلب إحصائيات المتابعات',
      error: error.message
    });
  }
};
// تشغيل المتابعات التلقائية الدورية (يمكن استدعاؤها من cron job)
exports.runAutomaticFollowUps = async (req, res) => {
  try {
    console.log('🤖 Running automatic follow-up scheduling...');

    await AutoFollowUpService.scheduleAutomaticFollowUps();

    res.json({
      success: true,
      message: 'تم تشغيل المتابعات التلقائية بنجاح'
    });

  } catch (error) {
    console.error('❌ Error running automatic follow-ups:', error);
    res.status(500).json({
      success: false,
      message: 'حدث خطأ أثناء تشغيل المتابعات التلقائية',
      error: error.message
    });
  }
};

// توزيع متابعات للعملاء المحتملين الموزعين
exports.distributeFollowUps = async (req, res) => {
  try {
    console.log('🎯 Distributing follow-ups for assigned leads...');
    
    const { followUpAssignments, createdBy } = req.body;
    
    if (!followUpAssignments || !Array.isArray(followUpAssignments)) {
      return res.status(400).json({
        success: false,
        message: 'يجب تمرير قائمة تخصيصات المتابعة'
      });
    }
    
    const results = await AutoFollowUpService.distributeFollowUpsWithLeads(
      followUpAssignments,
      createdBy || req.user.id
    );
    
    res.json({
      success: true,
      message: 'تم توزيع المتابعات بنجاح',
      data: results
    });
    
  } catch (error) {
    console.error('❌ Error distributing follow-ups:', error);
    res.status(500).json({
      success: false,
      message: 'حدث خطأ أثناء توزيع المتابعات',
      error: error.message
    });
  }
};

// إنشاء متابعات تلقائية لعميل محتمل
exports.createAutoLeadFollowUps = async (req, res) => {
  try {
    console.log('🤖 Creating auto follow-ups for lead...');
    
    const { leadId, assignedTo } = req.body;
    
    if (!leadId || !assignedTo) {
      return res.status(400).json({
        success: false,
        message: 'يجب تمرير معرف العميل المحتمل والموظف المخصص'
      });
    }
    
    const followUps = await AutoFollowUpService.createLeadFollowUps(leadId, assignedTo, req.user.id);
    
    res.json({
      success: true,
      message: 'تم إنشاء المتابعات التلقائية بنجاح',
      data: followUps
    });
    
  } catch (error) {
    console.error('❌ Error creating auto lead follow-ups:', error);
    res.status(500).json({
      success: false,
      message: 'حدث خطأ أثناء إنشاء المتابعات التلقائية',
      error: error.message
    });
  }
};

// Complete a follow-up
exports.completeFollowUp = async (req, res) => {
  try {
    const { id } = req.params;
    const { notes, outcome, next_action } = req.body;

    // جلب المتابعة مع البيانات المرتبطة
    const followUp = await FollowUp.findByPk(id, {
      include: [
        {
          model: Lead,
          as: 'lead',
          attributes: ['id', 'name', 'phone', 'email']
        },
        {
          model: Client,
          as: 'client', 
          attributes: ['id', 'name', 'phone', 'email']
        }
      ]
    });

    if (!followUp) {
      return res.status(404).json({
        success: false,
        message: 'متابعة غير موجودة'
      });
    }

    console.log(`✅ Completing follow-up ${id} with outcome: ${outcome}`);

    // Update follow-up status to done
    await followUp.update({
      status: 'done',
      completedDate: new Date(),
      notes: notes || followUp.notes,
      actualOutcome: outcome || followUp.actualOutcome,
      nextAction: next_action || followUp.nextAction
    });

    let nextFollowUp = null;

    // إنشاء متابعة تالية إذا تم تحديد النتيجة
    if (outcome && outcome !== 'not_interested') {
      try {
        nextFollowUp = await AutoFollowUpService.createNextFollowUp(
          followUp,
          outcome,
          next_action,
          followUp.assignedTo,
          req.user.id
        );
        
        if (nextFollowUp) {
          console.log(`🎯 Next follow-up created: ${nextFollowUp.title}`);
        }
      } catch (error) {
        console.error('⚠️ Failed to create next follow-up:', error);
        // لا نوقف العملية إذا فشلت المتابعة التالية
      }
    }

    res.json({
      success: true,
      message: 'تم إتمام المتابعة بنجاح',
      data: {
        completedFollowUp: followUp,
        nextFollowUp: nextFollowUp
      }
    });
  } catch (error) {
    console.error('Error completing follow-up:', error);
    res.status(500).json({
      success: false,
      message: 'خطأ في إتمام المتابعة'
    });
  }
};

// Get today's follow-ups for current user
exports.getTodayFollowUps = async (req, res) => {
  try {
    const today = new Date();
    const startOfDay = new Date(today.setHours(0, 0, 0, 0));
    const endOfDay = new Date(today.setHours(23, 59, 59, 999));

    const whereConditions = {
      scheduledDate: {
        [Op.between]: [startOfDay, endOfDay]
      },
      status: {
        [Op.in]: ['scheduled', 'rescheduled']
      }
    };

    // فلترة حسب الدور
    const userRole = req.user.role;
    if (userRole === 'sales' || userRole === 'sales_agent') {
      // موظفي المبيعات يرون متابعاتهم فقط
      // تحويل لـ number للتأكد من التطابق مع assignedTo في database
      whereConditions.assignedTo = parseInt(req.user.id);
    }
    // المدير والأدمن يرون جميع متابعات اليوم

    const followUps = await FollowUp.findAll({
      where: whereConditions,
      include: [
        {
          model: Client,
          as: 'client',
          attributes: ['id', 'name', 'email', 'phone'],
          required: false
        },
        {
          model: Lead,
          as: 'lead', 
          attributes: ['id', 'name', 'email', 'phone', 'status'],
          required: false
        }
      ],
      order: [['scheduledDate', 'ASC']],
      limit: 10
    });

    res.json({
      success: true,
      data: followUps,
      count: followUps.length
    });
  } catch (error) {
    console.error('Error fetching today follow-ups:', error);
    res.status(500).json({
      success: false,
      message: 'خطأ في جلب متابعات اليوم',
      error: error.message
    });
  }
};

// Delete all archived follow-ups permanently
exports.permanentDeleteAllFollowUps = async (req, res) => {
  try {
    console.log('🗑️ Permanently deleting all archived follow-ups');

    // Find all soft-deleted follow-ups
    const archivedFollowUps = await FollowUp.findAll({ 
      paranoid: false,
      where: {
        deleted_at: {
          [Op.not]: null
        }
      }
    });

    if (archivedFollowUps.length === 0) {
      return res.status(200).json({
        success: true,
        message: 'No archived follow-ups found to delete',
        deletedCount: 0
      });
    }

    const count = archivedFollowUps.length;

    // Remove related reminders for all archived follow-ups
    for (const followUp of archivedFollowUps) {
      await FollowUpIntegrationService.removeReminderForFollowUp(followUp.id);
    }
    
    // Permanently delete all archived follow-ups
    await FollowUp.destroy({ 
      force: true,
      paranoid: false,
      where: {
        deleted_at: {
          [Op.not]: null
        }
      }
    });

    console.log(`⚠️ ${count} follow-ups permanently deleted by ${req.user?.name || 'system'}`);

    res.json({
      success: true,
      message: `تم حذف ${count} متابعة نهائياً`,
      deletedCount: count
    });

  } catch (error) {
    console.error('❌ Error permanently deleting all follow-ups:', error);
    res.status(500).json({
      success: false,
      message: 'حدث خطأ أثناء الحذف النهائي لجميع المتابعات',
      error: error.message
    });
  }
};